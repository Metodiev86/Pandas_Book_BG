	 Въведение в Python 
 
	Първата глава на тази книга има за цел да постави солидна основа за изучаването на библиотеката Pandas, като запознае читателя с езика за програмиране Python. Ще започнем с кратко представяне на Python, неговата история и основни философски принципи. След това ще разгледаме къде и как може да бъде инсталиран Python, включително официалния уебсайт и популярни дистрибуции като Anaconda, както и основните стъпки при инсталацията. Ще научите как да стартирате Python в интерактивен режим и как да създавате и изпълнявате Python скриптове. Акцент ще бъде поставен върху отличителните черти на Python, които го правят уникален и предпочитан език за програмиране, особено в контекста на анализа на данни. Ще обсъдим неговия отворен код, интерпретирания характер, динамичното типизиране и лесния за четене синтаксис, който използва отстъпи вместо скоби за структуриране на кода и не изисква точка и запетая за край на ред. Ще споменем също голямата и активна общност, богатата екосистема от библиотеки и неговата мултипарадигменост. След като читателят придобие обща представа за Python, ще преминем към следващата глава, където ще се фокусираме конкретно върху причините, поради които Python е толкова мощен и предпочитан инструмент за анализ на данни.



	 Какво е Python? Първи стъпки и отличителни черти!
 
	Кратко представяне на Python: история и философия
Езикът за програмиране Python е създаден от Guido van Rossum в края на 80-те и началото на 90-те години в Националния изследователски институт по математика и компютърни науки (CWI) в Нидерландия. Той е замислен като наследник на езика ABC, с фокус върху четимостта на кода и продуктивността на програмиста. Името "Python" идва от любимото комедийно шоу на Guido van Rossum - "Monty Python's Flying Circus".
Философията на Python е обобщена в така наречения "The Zen of Python" (Дзен на Python), който може да бъде достъпен чрез изпълнение на командата import this в Python интерпретатора. Някои от ключовите принципи включват:
	Красивото е по-добро от грозното. (Beauty is better than ugly.)
	Явното е по-добро от неявното. (Explicit is better than implicit.)
	Простото е по-добро от сложното. (Simple is better than complex.)
	Сложното е по-добро от усложненото. (Complex is better than complicated.)
	Четливостта е важна. (Readability counts.)
Тези принципи са в основата на дизайна на езика и допринасят за неговата лекота на учене и използване. Python се стреми да предостави елегантен и чист синтаксис, който да намали усилието, необходимо за писане и разбиране на код.
През годините Python претърпява значително развитие, като се появяват важни версии като Python 2 и Python 3. Въпреки че Python 2 вече не се поддържа активно, Python 3 е текущата и бъдещата версия на езика, включваща множество подобрения и нови функционалности.
Благодарение на своята гъвкавост, мощност и богата екосистема от библиотеки, Python се използва в широк спектър от области, включително уеб разработка, наука за данни, изкуствен интелект, машинно обучение, автоматизация, научни изследвания, образование и много други. Неговата нарастваща популярност в областта на анализа на данни е една от основните причини да се фокусираме върху него в тази книга.

	Откъде да се сдобием с Python?
За да започнете да пишете и изпълнявате Python код, първо трябва да инсталирате интерпретатора на Python на вашата операционна система. Има няколко начина да го направите, като два от най-разпространените са чрез официалния уебсайт на Python или чрез използването на специализирани дистрибуции като Anaconda.
	Изтегляне от официалния уебсайт (Python.org)
Официалният уебсайт на Python (https://www.python.org/) е основният източник за изтегляне на Python интерпретатора за различни операционни системи (Windows, macOS, Linux).
 
	Навигирайте до секция Downloads.
 
	Ще видите бутон, който обикновено предлага най-новата стабилна версия на Python (в нашият случай е 3.13.3) за вашата операционна система. Кликнете върху него, за да изтеглите инсталационния файл.
	Ако имате нужда от конкретна версия или инсталатор за друга операционна система, можете да разгледате връзките под основния бутон за изтегляне.
Изтеглянето от официалния уебсайт ви предоставя базовата инсталация на Python, която включва стандартната библиотека. За по-нататъшна работа с анализ на данни, ще трябва да инсталирате допълнителни библиотеки като Pandas, NumPy и Matplotlib поотделно с помощта на пакетния мениджър pip, който е включен в стандартната инсталация. 
	Изтегляне от Anaconda
Anaconda (https://www.anaconda.com/) е безплатна и лесна за инсталиране дистрибуция на Python и R (друг език за статистически изчисления). Тя е особено популярна сред хората, занимаващи се с наука за данни и машинно обучение, тъй като включва предварително инсталирани множество от най-често използваните пакети, включително NumPy, Pandas, Matplotlib, SciPy, Jupyter Notebook и много други.
Предимствата на използването на Anaconda включват:
	Лесна инсталация: Инсталационният процес е опростен и бърз, особено за начинаещи.
	Предварително инсталирани пакети: Спестява време и усилия за ръчно инсталиране на множество библиотеки.
	Управление на среди (Environments): Anaconda улеснява създаването на изолирани среди за различни проекти, което помага за избягване на конфликти между версии на пакети.
	Jupyter Notebook: Включва Jupyter Notebook, интерактивна среда за разработка, която е изключително полезна за анализ на данни и визуализация.
	За да инсталирате Anaconda:
	Отворете уебсайта на Anaconda (https://www.anaconda.com/).
	Навигирайте до секция Downloads.
 
	Изберете версията на Python, която искате да инсталирате (препоръчително е да изберете най-новата стабилна версия на Python 3).
	Изберете инсталатора за вашата операционна система и изтеглете го.
 
	След като изтеглянето завърши, стартирайте инсталационния файл и следвайте инструкциите на екрана.
За начинаещи в анализа на данни, препоръчваме използването на Anaconda, тъй като то значително улеснява първоначалната настройка и ви предоставя всички необходими инструменти на едно място. Въпреки това, ако предпочитате по-минимална инсталация или имате специфични нужди, изтеглянето от официалния уебсайт и ръчното инсталиране на пакети също е напълно валиден подход.
	Инсталиране на Python (основни стъпки)
Процесът на инсталиране на Python може леко да варира в зависимост от вашата операционна система (Windows, macOS, Linux), но основните стъпки са сходни.
А. Инсталиране на Python от официалния уебсайт (python.org)
След като сте изтеглили инсталационния файл от https://www.python.org/downloads/, следвайте тези общи стъпки:
	За Windows:
	Стартирайте изтегления .exe файл.
	Уверете се, че сте отметнали опцията "Add Python X.X to PATH", където X.X е версията на Python, която инсталирате. Това ще ви позволи да изпълнявате Python команди от командния прозорец.
	Кликнете на "Install Now", за да започнете стандартната инсталация. Ако искате да персонализирате инсталацията (например да изберете друга директория), можете да кликнете на "Customize installation".
	Следвайте инструкциите на екрана до завършване на инсталацията.
	След като инсталацията е завършена, може да се наложи да рестартирате компютъра си, за да се обновят системните променливи на средата (особено ако не сте отметнали "Add Python to PATH" и сте го направили ръчно).
	За macOS:
	Стартирайте изтегления .pkg файл.
	Следвайте инструкциите на инсталатора, като приемете лицензионното споразумение и изберете местоположение за инсталация (обикновено по подразбиране е подходящо).
	Може да бъдете попитани за администраторска парола, за да продължите с инсталацията.
	След като инсталацията е завършена, Python ще бъде инсталиран на вашата система. macOS обикновено идва с предварително инсталирана версия на Python 2, но е важно да използвате версията, която сте изтеглили (обикновено Python 3).
	За Linux: В повечето Linux дистрибуции, Python вече е предварително инсталиран. Въпреки това, може да искате да инсталирате по-нова версия или да инсталирате пакетния мениджър pip, ако не е наличен. Процесът може да варира в зависимост от дистрибуцията (например Ubuntu, Fedora, CentOS). Обикновено можете да използвате пакетния мениджър на вашата дистрибуция (като apt за Debian/Ubuntu или yum/dnf за Fedora/CentOS) за инсталиране на Python и pip
Пример за Ubuntu:
sudo apt update
sudo apt install python3 python3-
Пример за Fedora:
sudo dnf 
install python3 python3-pip

След инсталацията от официалния уебсайт (за Windows и macOS) или чрез пакетния мениджър (за Linux), трябва да проверите дали Python е инсталиран успешно. Отворете командния прозорец (Command Prompt в Windows, Terminal в macOS/Linux) и въведете:
Ако Python е инсталиран правилно, ще видите изведена версията на Python. Също така, проверете дали pip е инсталиран:
Ако pip е инсталиран, ще видите информация за неговата версия. pip е важен инструмент, който ще използвате за инсталиране на допълнителни Python библиотеки, включително Pandas.
Б. Инсталиране на Anaconda
След като сте изтеглили инсталационния файл на Anaconda от https://www.anaconda.com/download/, следвайте тези общи стъпки:
	За Windows:
	Стартирайте изтегления .exe файл.
	Кликнете на "Next", приемете лицензионното споразумение и изберете типа инсталация (препоръчително е "Just Me").
	Изберете местоположение за инсталация (по подразбиране обикновено е подходящо).
	Важно е да отметнете опцията "Add Anaconda to my PATH environment variable". Това ще ви позволи да използвате Anaconda команди от командния прозорец. Може да получите предупреждение, че това може да причини проблеми с друг инсталиран Python, но за начинаещи обикновено е по-удобно да бъде отметната.
	Можете също да отметнете "Register Anaconda as my default Python 3.x", което ще направи Anaconda Python интерпретатора по подразбиране.
	Кликнете на "Install" и изчакайте до завършване на инсталацията.
	След инсталацията, можете да отворите Anaconda Navigator от менюто "Старт" (в Windows) или да използвате Anaconda Prompt (команден прозорец, специфичен за Anaconda) за управление на пакети и среди.
	За macOS:
	Стартирайте изтегления .pkg файл.
	Следвайте инструкциите на инсталатора, като приемете лицензионното споразумение и изберете местоположение за инсталация.
	Може да бъдете попитани за администраторска парола.
	След инсталацията, Anaconda ще бъде инсталирана. Можете да използвате Anaconda Navigator (намира се в Applications) или Anaconda Terminal за управление на пакети и среди.


	За Linux:
	Отворете терминал и навигирайте до директорията, където сте изтеглили .sh файла на Anaconda.
	Изпълнете командата за стартиране на инсталатора (може да се наложи да дадете права за изпълнение на файла с chmod +x Anaconda... .sh): 
bash Anaconda3-XXXXXXXX-Linux-x86_64.sh
(Заменете Anaconda3-XXXXXXXX-Linux-x86_64.sh с точното име на изтегления файл).
	Следвайте инструкциите на екрана, като приемете лицензионното споразумение и изберете местоположение за инсталация.
	Ще бъдете попитани дали искате да инициализирате Anaconda3, отговорете с yes. Това ще добави Anaconda към вашия PATH.
	След инсталацията, затворете и отворете отново терминала, за да се активират промените в PATH. Можете да проверите инсталацията с командата conda --version.
След успешна инсталация на Anaconda, ще имате достъп до множество предварително инсталирани библиотеки, включително Pandas, и ще можете да използвате Anaconda Navigator или conda (команден инструмент на Anaconda) за управление на пакети и среди.
	Първо стартиране: интерактивен режим и създаване на скриптове (.py файлове)
След като сте инсталирали успешно Python, има два основни начина да започнете да пишете и изпълнявате Python код: чрез интерактивния режим и чрез създаване на скриптове (.py файлове).
	Интерактивен режим (Interactive Mode)
Интерактивният режим на Python е среда, в която можете да въвеждате Python команди ред по ред и да виждате резултата веднага. Той е изключително полезен за експериментиране, бързо тестване на идеи и разучаване на езика.
	Стартиране на интерактивния режим:
	Отворете командния прозорец (Command Prompt в Windows) или терминал (Terminal в macOS/Linux).
	Въведете python (или python3 в някои Linux системи или ако имате инсталирани няколко версии на Python) и натиснете Enter.
	Ако Python е инсталиран правилно и е добавен към PATH (или ако използвате Anaconda Prompt/Terminal), ще видите промпт, който изглежда подобно на >>>. Това означава, че Python интерпретаторът е готов да приема команди.
	Използване на интерактивния режим: Вече можете да въвеждате Python код директно след промпта >>> и да натискате Enter, за да го изпълните. Резултатът от изпълнението ще се покаже веднага под командата.
>>> 2 + 2
4
>>> print("Hello, Python!")
Hello, Python!
>>> name = "World"
>>> print(f"Hello, {name}!")
Hello, World!

	Излизане от интерактивния режим: За да излезете от интерактивния режим, можете да въведете exit() или да натиснете Ctrl+Z и Enter (в Windows) или Ctrl+D (в macOS/Linux).

	Създаване и изпълнение на скриптове (.py файлове)
За по-сложни програми или за код, който искате да запазите и изпълнявате многократно, е по-добре да пишете Python код в текстови файлове с разширение .py. Тези файлове се наричат Python скриптове.
	Създаване на Python скрипт:
	Отворете текстов редактор (например Notepad в Windows, TextEdit в macOS, VS Code, Sublime Text, PyCharm и др.).
	Напишете вашия Python код в редактора. Например:
# Това е прост Python скрипт
def greet(person):
    print(f"Здравей, {person}!")
name = "Потребител"
greet(name)
	Запазете файла с разширение .py (например hello.py). Изберете подходяща директория, където искате да го запазите.
	Изпълнение на Python скрипт:
	Отворете командния прозорец (Command Prompt в Windows) или терминал (Terminal в macOS/Linux).
	Навигирайте до директорията, където сте запазили .py файла, използвайки командата cd (change directory). Например, ако файлът е запазен в директория "Documents/PythonScripts", ще използвате:	
python hello.py
	Резултатът от изпълнението на скрипта ще се покаже в командния прозорец:
	Избор между интерактивен режим и скриптове:
	Използвайте интерактивния режим за: 
	Бързи експерименти и тестване на отделни команди.
	Разглеждане на променливи и резултати веднага.
	Разучаване на нови функции и библиотеки.
	Използвайте скриптове (.py файлове) за: 
	По-големи и сложни програми.
	Код, който искате да запазите и изпълнявате многократно.
	Организиране на код в логически модули.
	Разбирането на разликата между тези два начина на работа с Python е важно за ефективното му използване. В следващите глави ще използваме и двата подхода за илюстрация на концепции и примери.
	Отличителни черти на Python:
Python притежава редица характеристики, които го правят популярен и предпочитан език за програмиране в много области, включително анализ на данни. Ето основните от тях:
	Open source (с отворен код): Python е език с отворен код, което означава, че неговият изходен код е свободно достъпен за всеки да го разглежда, използва, модифицира и разпространява. Това насърчава сътрудничеството в общността и води до бързо развитие и обогатяване на езика. Лицензът на Python е гъвкав и позволява използването му както в проекти с отворен, така и със затворен код.
	Интерпретируем език: Python е интерпретируем език, което означава, че кодът се изпълнява ред по ред от интерпретатор, без да е необходимо предварително компилиране в машинен код (както е при езици като C++ или Java). Това улеснява процеса на разработка и тестване, тъй като можете да изпълнявате кода си веднага след като го напишете.
	Динамично типизиране: Както вече споменахме, Python е динамично типизиран език. Това означава, че не е нужно изрично да декларирате типа на променливата, когато я създавате. Типът се определя по време на изпълнение въз основа на присвоената стойност. Това прави кода по-кратък и по-гъвкав, но изисква внимателно следене за типови грешки по време на разработка.
	Четлив синтаксис (използване на отстъпи (табулация) за блокове код): Една от най-забележителните характеристики на Python е неговият чист и лесен за четене синтаксис. Вместо да използва специални символи като къдрави скоби за обозначаване на блокове код (например за if конструкции, цикли, функции и класове), Python използва отстъпи (indentation). Нивото на отстъп определя към кой блок код принадлежи даден ред. Това принуждава програмистите да пишат структуриран и визуално подреден код, което значително подобрява четимостта и поддръжката. Препоръчително е да се използват 4 интервала (или една табулация, но е важно да се поддържа консистентност в рамките на един проект) за всяко ниво на отстъп.
python hello.py # Пример за използване на отстъпи
age = 25
if age >= 18:
    print("Пълнолетен")  # Този ред е част от if блока
    can_vote = True     # И този също
else:
    print("Непълнолетен") # Този ред е част от else блока
    can_vote = False     # И този също
	Без използване на къдрави скоби {} (както в C-базираните езици) или begin/end (както в Pascal/Delphi) за разграничаване на блокове код: Както стана ясно от предходната точка, Python се отличава с елегантния си начин за структуриране на код чрез отстъпи, елиминирайки необходимостта от тромави конструкции като {} или begin/end, които могат да направят кода по-труден за четене и писане.
Пример 1: Условна конструкция (if-else)
В C++ и Java, къдравите скоби {} се използват за определяне началото и края на блоковете код, принадлежащи на if и else конструкциите.
	C++ :
int age = 15;
if (age >= 18) {
    std::cout << "Пълнолетен" << std::endl;
    bool canVote = true;
} else {
    std::cout << "Непълнолетен" << std::endl;
    bool canVote = false;
}
std::cout << "Край на проверката" << std::endl;

	Java:
int age = 15;
if (age >= 18) {
    System.out.println("Пълнолетен");
    boolean canVote = true;
} else {
    System.out.println("Непълнолетен");
    boolean canVote = false;
}
System.out.println("Край на проверката");

	Pascal / Delphi:
var
  age: Integer;
  canVote: Boolean;
begin
  age := 15;
  if age >= 18 then
  begin
    Writeln('Пълнолетен');
    canVote := True;
  end
  else
  begin
    Writeln('Непълнолетен');
    canVote := False;
  end;
  Writeln('Край на проверката');
end.
	В Pascal и Delphi, ключовите думи begin и end се използват за очертаване на блоковете код след if и else.
	Python:
age = 15
if age >= 18:
    print("Пълнолетен")
    can_vote = True
else:
    print("Непълнолетен")
    can_vote = False
print("Край на проверката")
Пример 2: Цикъл (for):
C++:
for (int i = 0; i < 5; ++i) {
    std::cout << i << std::endl;
}
Java:
for (int i = 0; i < 5; i++) {
    System.out.println(i);
}
Pascal/Delphy:
var i: Integer;
begin
  for i := 0 to 4 do
  begin
    Writeln(i);
  end;
end.

Python:
for i in range(5):
    print(i)
В Python, блоковете код се определят единствено от нивото на отстъп. Редовете с еднакво ниво на отстъп принадлежат към един и същ блок. След if и else следва двоеточие :.
	Тези примери ясно показват как Python използва отстъпи за структуриране на кода, което го прави по-визуално подреден и често по-лесен за четене в сравнение с езиците, използващи скоби или ключови думи за същата цел.

	Не се изисква точка и запетая (;) за край на ред (въпреки че може да се използва за разделяне на множество оператори на един ред, което не е препоръчително за четимост):
В Python, краят на реда обикновено означава край на оператора. Не е необходимо да завършвате всеки ред с точка и запетая, както в някои други езици. Въпреки че технически е възможно да използвате точка и запетая за разделяне на няколко оператора на един ред, това се счита за лоша практика и се избягва, тъй като намалява четимостта на кода.

# Стандартен начин на писане
x = 5
y = 10
print(x + y)

# Възможно, но не се препоръчва
x = 5; y = 10; 
print(x + y)	
	Голяма и активна общност: Python има една от най-големите и най-активните общности от програмисти в света. Това означава, че има изобилие от онлайн ресурси, документация, уроци, форуми и помощ, достъпни за всеки, който учи или използва езика. Ако срещнете проблем или имате въпрос, най-вероятно вече има някой, който се е сблъсквал със същия проблем и е споделил решението си.
	Богата екосистема от библиотеки и фреймуърци: Едно от най-големите предимства на Python е неговата огромна колекция от библиотеки и фреймуърци, които разширяват функционалността на езика за различни задачи. За анализ на данни, вече споменахме Pandas, NumPy, Matplotlib и Seaborn. Има също така мощни фреймуърци за уеб разработка (Django, Flask), машинно обучение (Scikit-learn, TensorFlow, PyTorch), научни изчисления (SciPy), автоматизация и много други. Тази богата екосистема значително ускорява процеса на разработка, тъй като често можете да намерите готови решения на често срещани проблеми.
	Мултипарадигмен (поддържа обектно-ориентирано, процедурно и функционално програмиране): Python не ви ограничава до един определен стил на програмиране. Можете да пишете код, използвайки процедурен подход (последователност от инструкции), обектно-ориентиран подход (използване на класове и обекти) или функционален подход (използване на функции като първокласни обекти). Тази гъвкавост ви позволява да избирате най-подходящия стил за конкретния проблем, който решавате.
Тези отличителни черти правят Python мощен, гъвкав и лесен за използване език, който e особено подходящ за анализ на данни и много други области на програмирането. В следващите глави ще видим как тези характеристики се проявяват на практика, докато изучаваме библиотеката Pandas.
	Защо Python за анализ на данни?
 


В предходната глава бе представена кратка информационна справка за езика за програмиране Python и неговите отличителни черти. Сега ще се фокусираме конкретно върху причините, поради които Python се е превърнал в един от най-популярните и предпочитани инструменти за анализ на данни, наука за данни (Data Science) и машинно обучение (Machine Learning).
Популярността на Python в тази област не е случайна, а се дължи на комбинация от мощни характеристики, богата екосистема от библиотеки и активна общност, които заедно предоставят изключително ефективна и гъвкава среда за работа с информация.
Ето някои от основните причини, поради които Python е толкова успешен в анализа на данни:
	Обширна и специализирана екосистема от библиотеки: Както вече споменахме, Python разполага с огромно количество от висококачествени библиотеки, създадени специално за нуждите на анализа на данни. Тези библиотеки предоставят готови решения за широк кръг от задачи, от манипулиране и почистване на данни до сложни статистически анализи и моделиране. Някои от най-важните и често използвани библиотеки включват:
	NumPy: Фундаментална библиотека за числени изчисления, която осигурява поддръжка за многомерни масиви (arrays) и богата колекция от математически функции, оптимизирани за бързи и ефективни операции с големи набори от данни.
	Pandas: Основната библиотека, на която е посветена тази книга, предоставяща мощни и гъвкави структури от данни като Series (едномерен етикетиран масив) и DataFrame (двумерна таблична структура), както и инструменти за лесно манипулиране, почистване, филтриране, групиране и анализ на данни от различни източници.
	Matplotlib: Библиотека за създаване на статични, интерактивни и анимирани визуализации на данни в Python. Тя предлага голям контрол върху всеки аспект на графиката, което позволява създаването на персонализирани и информативни визуализации.
	Seaborn: Библиотека, построена върху Matplotlib, която предоставя по-високо ниво интерфейс за създаване на атрактивни и информативни статистически графики с по-малко код. Тя е особено полезна за изследване на зависимости между променливи и разпределения на данни.
	SciPy: Библиотека, съдържаща множество модули за научни и технически изчисления, включително статистически функции, оптимизация, линейна алгебра, интеграция, интерполация и др. Тя разширява възможностите на NumPy с допълнителни научни инструменти.
	Scikit-learn: Мощна библиотека за машинно обучение, която включва реализации на много класически алгоритми за класификация, регресия, клъстериране, намаляване на размерността, избор на модел и предварителна обработка на данни.
	Лесен за учене и използване синтаксис: Чистият и интуитивен синтаксис на Python значително улеснява както начинаещите, така и опитните програмисти да пишат, четат и разбират код за анализ на данни. Това намалява времето, необходимо за усвояване на езика и позволява на анализаторите да се фокусират повече върху самите данни и извличането на знания от тях, отколкото върху сложността на езика за програмиране.
	Гъвкавост и интеграция: Python е много гъвкав език, който може да се използва за целия процес на анализ на данни - от събиране и почистване на данни до моделиране и визуализация. Той също така се интегрира лесно с други езици (като C, C++, R) и инструменти, което позволява използването на съществуващи решения и оптимизация на критични части от кода. Възможността за свързване с различни бази данни и файлови формати също е ключово предимство.
	Активна и подкрепяща общност: Голямата и активна общност от Python разработчици и специалисти по данни означава лесен достъп до помощ, документация, примери и споделен код. Онлайн форуми, уебсайтове и социални мрежи са пълни с ресурси и дискусии, които могат да помогнат при решаването на проблеми и научаването на нови техники.
	Възможности за визуализация: Библиотеките Matplotlib и Seaborn, както и други инструменти за визуализация в Python, предоставят богати възможности за създаване на графики и диаграми, които помагат за разбирането на данните, идентифицирането на модели и комуникирането на резултатите от анализа.
	Интеграция с машинно обучение и изкуствен интелект: Python е основният език, използван в областта на машинното обучение и изкуствения интелект. Библиотеки като Scikit-learn, TensorFlow и PyTorch предлагат мощни инструменти за изграждане и обучение на сложни модели. Тъй като анализът на данни често е стъпка към по-нататъшно моделиране и прогнозиране, тази интеграция е изключително ценна.
	В заключение, Python предлага цялостна, мощна и лесна за използване платформа за анализ на данни. Неговата богата екосистема от библиотеки, четим синтаксис, гъвкавост и активна общност го правят идеален избор за всеки, който работи с данни, независимо дали е начинаещ или опитен професионалист. В следващите глави ще започнем да разглеждаме една от най-важните библиотеки в тази екосистема – Pandas.

 
	Основни типове данни в Python (част 1: Примитивни типове)
 

Една от ключовите характеристики на езика за програмиране Python е неговото слабо (или динамично) типизиране. Това означава, че за разлика от строго типизираните езици (като C++ или Java), не е необходимо изрично да декларирате типа на променливата, когато я създавате. Интерпретаторът на Python автоматично определя типа на променливата по време на изпълнение въз основа на стойността, която ѝ присвоявате.
x = 10      # Python автоматично разбира, че x е цяло число (int)
y = 3.14 	  # Python автоматично разбира, че y е десетично число (float)
z = "Hello" # Python автоматично разбира, че z е низ (str)
Например:
Въпреки че не е нужно изрично да указвате типа, важно е да разбирате различните типове данни, които поддържа, тъй като те определят какви операции могат да бъдат извършвани Python с тях и как се държат те в програмата.
	Конвеция за именуване:
Преди да се потопим в специфичните примитивни типове данни, е важно да се запознаем с конвенциите за именуване (naming conventions) в Python. Следването на тези общоприети правила прави кода по-лесен за четене, разбиране и поддръжка от вас и от други програмисти. Въпреки че Python не налага стриктно тези конвенции, силно се препоръчва да ги спазвате за създаване на качествен и професионален код.
Ето основните конвенции за именуване в Python:
	Променливи: Името на променливите обикновено се пише с малки букви, а отделните думи се разделят с долна черта (snake_case).
	Пример: my_variable, user_name, total_count
	Константи: Името на константите обикновено се пише с главни букви, а отделните думи се разделят с долна черта.
	Пример: PI, MAX_USERS, DEFAULT_TIMEOUT
	Функции: Името на функциите също следва конвенцията snake_case, като се пише с малки букви, а думите се разделят с долна черта.
	Пример: calculate_average(), get_user_details(), is_valid_input()
	Класове: Името на класовете обикновено се пише с първа главна буква за всяка дума (PascalCase или CamelCase с първа главна буква).
	Пример: MyClass, UserData, ShoppingCart
	Модули и пакети: Името на модулите обикновено се пише с малки букви, а отделните думи могат да бъдат разделени с долна черта (за модули) или да бъдат кратки имена с малки букви (за пакети).
	Пример (модул): my_module.py, data_processing.py
	Пример (пакет): mypackage, utils
	Защита на членове (атрибути и методи на клас):
	Имената, започващи с една долна черта (_), се считат за вътрешни или защитени членове и не трябва да бъдат директно достъпвани извън класа (въпреки че Python не го забранява). 
	Пример: _internal_variable, _calculate_internal()
	Имената, започващи с две долни черти (__), водят до name mangling и са предназначени за по-силна защита (но не са напълно скрити). 
	Пример: __private_variable, __process_data()

	Следвайки тези конвенции, вие ще пишете код, който е по-организиран, по-лесен за разбиране от други програмисти и по-съвместим с общоприетите стандарти в Python общността. Нека сега се фокусираме върху първите от основните типове данни в Python...


Сега нека разгледаме основните числови типове данни в Python:
	Числа(Numbers)
	Цели числа (int)
Целите числа представляват цели стойности без дробна част. Те могат да бъдат както положителни, така и отрицателни, и нямат ограничение за размера си (стига да има достатъчно памет на компютъра).
count_apple = 5
negative_number = -10
big_number = 12345678901234567890
print(type(count_apple))       # Извежда: <class 'int'>
print(type(negative_number))   # Извежда: <class 'int'>
print(type(big_number))        # Извежда: <class 'int'>
Можете да извършвате стандартни аритметични операции с цели числа: събиране (+), изваждане (-), умножение (*), деление (/), целочислено деление (//), остатък при деление (%) и степенуване (**).
a = 10            
b = 3           
sum = a + b                     # 13    
difference = a - b              # 7
multiplication = a * b          # 30  
division = a / b            # 3.333... (резултатът е float)
integer division = a // b       # 3
remainder = a % b               # 1
grading = a ** b                # 1000

	Десетични числа (float)
Десетичните числа (числа с плаваща запетая) представляват реални числа с дробна част. Те се използват за представяне на стойности, които не са цели.
price = 9.99
temperature = 25.5
tiny_number = 0.0001
print(type(price))         # Извежда: <class 'float'>
print(type(temperature))   # Извежда: <class 'float'>
print(type(tiny_number))   # Извежда: <class 'float'>
Същите аритметични операции, които са валидни за цели числа, могат да се прилагат и към десетични числа. Важно е да се отбележи, че резултатът от деление (/) винаги е число от тип float, дори ако операндите са цели числа.
c = 5.0
d = 2.0
sum_float = c + d         # 7.0
devision_float = c / d      # 2.5 
	!!! Внимание: Поради начина, по който компютрите представят числата с плаваща запетая, може да има малки неточности при някои операции.

	Комплексни числа (complex)
Комплексните числа имат реална и имагинерна част и се записват във формата a + bj, където a е реалната част, b е имагинерната част, а j е имагинерната единица (√(-1)).
complex_1 = 3 + 4j
complex_2 = -1 - 2j
print(type(complex_1))   # Извежда: <class 'complex'>
print(complex_1.real)    # Извежда: 3.0 (реалната част)
print(complex_1.imag)    # Извежда: 4.0 (имагинерната част)

Python поддържа аритметични операции с комплексни числа:
sum_complex = complex_1 + complex_2     # 2 - 2j
multi_complex = complex_1 + complex_2   # (-11+2j)
Комплексните числа често се използват в научни и инженерни приложения.
	Това е въведение в основните числови типове данни в Python. В следващите подглави ще разгледаме други примитивни типове като низове и булеви стойности.

	Низове (Strings)
Низовете в Python представляват последователности от знаци. Те се използват за съхраняване и манипулиране на текстовa информация. Низовете са неизменяем тип данни, което означава, че след като бъде създаден, не можете директно да променяте отделните му знаци. Всяка операция, която изглежда променя низ, всъщност създава нов низ.
single_quoted = 'Това е низ, ограден с единични кавички.'
double_quoted = "Това е низ, ограден с двойни кавички."
triple_quoted_single = '''Това е многоредов
низ, ограден с тройни
единични кавички.'''
triple_quoted_double = """Това също е многоредов
низ, ограден с тройни
двойни кавички."""
print(single_quoted)
print(double_quoted)
print(triple_quoted_single)
print(triple_quoted_double)
print(type(single_quoted))   # Извежда: <class 'str'>

	Създаване и манипулиране на низове 
Низовете могат да бъдат създадени чрез ограждане на последователност от знаци в единични ('...'), двойни ("...") или тройни кавички ('''...''' или """...""").
example1 = "Той каза: 'Здравейте!'"
example2 = 'Тя попита: "Как си?"'
example3 = '''Това е низ, който съдържа както 'единични', така и "двойни" кавички.'''
print(example1)
print(example2)
print(example3)
Използването на различни видове кавички позволява лесното включване на кавички вътре в низа без нужда от екраниране:
Тройните кавички са особено полезни за създаване на многоредови низове, както видяхме по-горе, и за документиращи низове (docstrings) във функции и класове.
	Манипулиране на низове:
Python предлага богат набор от вградени функции и методи за манипулиране на низове. Ето някои от основните:
	Конкатенация (съединяване): Низове могат да бъдат съединявани с помощта на оператора +:
str1 = "Здравей"
str2 = " свят!"
result = str1 + str2
print(result)   # Извежда: Здравей свят!

	Повтаряне: Низ може да бъде повторен многократно с помощта на оператора *:
repeat_str = "abc" * 3
print(repeat_str) # Извежда: abcabcabc

	Достъп до знаци (индексиране): Отделните знаци в низа могат да бъдат достъпени чрез техния индекс (позиция), като индексирането започва от 0. Може да се използва и отрицателно индексиране, където -1 е последният знак, -2 е предпоследният и т.н.
my_string = "Python"
print(my_string[0])   # Извежда: P
print(my_string[3])   # Извежда: h
print(my_string[-1])  # Извежда: n
print(my_string[-2])  # Извежда: o

	Слайсиране (извличане на подниз): Можете да извлечете подниз от низ, като използвате нотацията за слайсиране [start:end:step]:
my_string = "Programming"
print(my_string[0:4])  # Извежда: Prog (от индекс 0 до 4, без 4)
print(my_string[4:])   # Извежда: ramming (от индекс 4 до края)
print(my_string[:7]) # Извежда: Program (от началото до индекс 7, без 7)
print(my_string[::2])  # Извежда: Pormn (всеки втори знак)
print(my_string[::-1]) # Извежда: gnimmargorP (обръща низа)

	Вградени методи за низове: Python предлага множество вградени методи за работа с низове. Някои често използвани включват:
	.lower(): връща низ с всички букви в малък регистър.
	.upper(): връща низ с всички букви в голям регистър.
	.strip(): премахва водещи и последващи празни символи (интервали, табулации, нови редове).
	.split(separator): разделя низа на списък от поднизове въз основа на зададен разделител.
	.join(iterable): съединява елементите на итерируем обект (например списък) в един низ, като между тях вмъква низа, за който е извикан методът.
	.replace(old, new): заменя всички срещания на old подниз с new подниз.
	.find(substring): връща индекса на първото срещане на substring в низа, или -1, ако не е намерен.
	.startswith(prefix): връща True, ако низът започва с prefix, False в противен случай.
	.endswith(suffix): връща True, ако низът завършва със suffix, False в противен случай.
text = "  Примерен Низ  "
print(text.lower())         # Извежда:   примерен низ
print(text.upper())         # Извежда:   ПРИМЕРЕН НИЗ
print(text.strip())         # Извежда: Примерен Низ
print(text.split(" "))      # Извежда: ['', '', 'Примерен', 'Низ', '', '']
words = ["Python", "е", "мощен"]
print(" ".join(words))          # Извежда: Python е мощен
print(text.replace("Низ", "текст"))   # Извежда:   Примерен текст
print(text.find("ерен"))          # Извежда: 5
print(text.startswith(" "))     # Извежда: True
print(text.endswith(" "))       # Извежда: True

	Форматиране на низове:
Python предлага няколко начина за вмъкване на стойности на променливи в низове. Два от най-съвременните и често използвани метода са f-strings (от Python 3.6+) и методът .format().
	f-strings (форматирани низови литерали): f-strings предоставят елегантен и четим начин за вграждане на изрази вътре в низови литерали, като се предхождат от f или F.

name = "Алиса"
age = 30
print(f"Здравей, {name}! Ти си на {age} години.")
#Изход: Здравей, Алиса! Ти си на 30 години.
price = 19.99
print(f"Цената е ${price:.2f}") # Форматиране до два знака след десетичната запетая
##Изход: Цената е $19.99

calculation = 5 * 2

calculation = 5 * 2
print(f"5 умножено по 2 е {calculation}.")
	Метод .format(): Методът .format() е по-стар начин за форматиране на низове, но все още се използва. Той използва заместващи полета {} в низа и приема аргументи, които се вмъкват на тези места.
	Разбирането и ефективното използване на низове и методите за тяхната манипулация и форматиране е от съществено значение при работа с данни, тъй като често данните се съхраняват и обработват като текст.

	Булеви типове (Booleans)
Булевите типове данни представляват логически стойности. В Python има два булеви обекта:
True (истина) и False (лъжа). Тези стойности често са резултат от логически операции или операции за сравнение.
is_valid = True
is_empty = False

print(type(is_valid))   # Извежда: <class 'bool'>
print(type(is_empty))   # Извежда: <class 'bool'>
	True и False:
True и False са ключови думи в Python и трябва да се пишат точно както са (с главна първа буква). Те представляват двете възможни състояния на истинност.
Булевите стойности често се използват в условни конструкции (if, elif, else) и цикли (while), за да контролират потока на изпълнение на програмата въз основа на истинността на дадено условие.
user_logged_in = True
if user_logged_in:
  print("Потребителят е влязъл.")
else:
  print("Потребителят не е влязъл.")

Интересно е да се отбележи, че в Python булевите стойности също могат да бъдат третирани като цели числа: True се интерпретира като 1, а False като 0. Въпреки че не е препоръчително да се разчита на това за аритметични операции в повечето случаи, е важно да се знае, че това поведение съществува.
print(True + 1)    # Извежда: 2
print(False + 5)   # Извежда: 5
print(True * False) # Извежда: 0

	Логически операции (and, or, not):
Python предоставя три основни логически оператора, които се използват за комбиниране и модифициране на булеви стойности:
	and (логическо И): 
Операторът and връща True, ако и двата операнда са True. В противен случай връща False

 











	or (логическо ИЛИ):
 Операторът or връща True, ако поне един от операндите е True. Връща False само ако и двата операнда са False.

 


	not (логическо НЕ): 
Операторът not е унарен оператор (действа върху един операнд) и връща обратната булева стойност на операнда. Ако операндът е True, not връща False, и обратното

 

	kомбинации от логически оператори. 
Логическите оператори могат да бъдат комбинирани, за да се създават по-сложни булеви изрази. Важно е да се помни редът на изпълнение на операторите (not има най-висок приоритет, следван от and, и накрая or). Можете да използвате скоби, за да промените реда на изпълнение и да направите изразите по-ясни.



a = True
b = False
c = True
result1 = a and not b or c
print(result1) # Извежда: True (not False е True, True and True е True, True or True е True)

result2 = (a and (not b)) or c
print(result2) # Извежда: True (същото като горното, но по-ясно със скоби)
result3 = a and (not (b or c))
print(result3) # Извежда: False (b or c е True, not True е False, True and False е False) 
	Булевите типове данни и логическите операции са фундаментални за вземане на решения и контролиране на потока на изпълнение в програмите и играят важна роля при филтрирането и обработката на данни.

	Обобщение на примитевните типове данни:
Тип данни	Описание	Минимална стойност	Максимална стойност	Бележки
int	Цели числа (без десетична запетая)	Теоретично неограничен (ограничен от паметта на системата)	Теоретично неограничен (ограничен от паметта на системата)	В Python 3 int може да представлява произволно големи цели числа.
float	Числа с плаваща запетая (десетични числа)	Приблиз.
1.7976931348623157e-308	Приблиз. 1.7976931348623157e+308	Базиран на стандарта IEEE 754 за двойна точност. Минималната и максималната стойност могат да варират леко в зависимост от системата.
complex	Комплексни числа (с реална и имагинерна част)	Няма строги граници за целия комплекс, но реалната и имагинерната част са float.	Няма строги граници за целия комплекс, но реалната и имагинерната част са float.	Представляват числа във формата a + bj, където a е реалната част, а b е имагинерната част.
str	Низ (последователност от знаци)	Теоретично празен низ ""	Теоретично ограничен от паметта на системата	Може да съдържа произволно дълги последователности от Unicode символи.
bool	Булев тип (логически стойности)	False (числено еквивалентно на 0)	True (числено еквивалентно на 1)	Представлява истинностни стойности.

Важни бележки:
	int в Python 3: За разлика от много други езици, където int има фиксиран размер (например 32-битов или 64-битов), в Python 3 целият тип int може да нарасне до размера на наличната памет, което позволява работа с изключително големи числа без препълване.
	float: Стойностите за float са приблизителни и са базирани на стандарта IEEE 754 за двойна точност. Това означава, че не всички реални числа могат да бъдат представени точно като float.
	complex: Комплексните числа се състоят от две части, всяка от които е float. Следователно, ограниченията за реалната и имагинерната част са същите като за float.
	str: Дължината на низа е ограничена от наличната памет на системата.
	bool: Булевите стойности са подмножество на целите числа (числено False е 0, а True е 1).
	NoneType: None е специална константа, която представлява липса на стойност или нулева стойност. Това е единствената стойност, която може да има променлива от тип NoneType.

	Преобразуване на типове - Type Casting
В Python често се налага да преобразувате стойности от един тип данни в друг. Този процес се нарича "type casting" или "преобразуване на типове". Python предоставя няколко вградени функции за извършване на тези преобразувания.
	Към цяло число int():
 Преобразува стойност към цяло число. Ако подаденият аргумент е десетично число, дробната част се отрязва. Ако е низ, той трябва да представлява валидно цяло число.

float_num = 3.14
int_num = int(float_num)
print(int_num)        # Извежда: 3
print(type(int_num))  # Извежда: <class 'int'>

str_num = "123"
int_from_str = int(str_num)
print(int_from_str)   # Извежда: 123
print(type(int_from_str)) # Извежда: <class 'int'>

# int("3.14") # Ще генерира ValueError: invalid literal for int() with base 10: '3.14'

	От число с плаваща запетая (float): 
Както беше споменато, при преобразуване на float към int, дробната част винаги се отрязва (закръгляне към нула), а не се закръглява към най-близкото цяло число.
float_positive = 3.7
int_positive = int(float_positive)
print(f"int({float_positive}) = {int_positive}")   # Извежда: int(3.7) = 3

float_negative = -3.7
int_negative = int(float_negative)
print(f"int({float_negative}) = {int_negative}")   # Извежда: int(-3.7) = -3

	От низ (str) към цяло число: 
Когато преобразувате низ към цяло число, низът трябва да представлява валидно цяло число. Той може да съдържа водещи и завършващи интервали, както и необязателен знак (+ или -).
valid_str = "  -42  "
int_from_valid_str = int(valid_str)
print(f"int('{valid_str}') = {int_from_valid_str}") # Извежда: int('  -42  ') = -42

positive_str = "+100"
int_from_positive = int(positive_str)
print(f"int('{positive_str}') = {int_from_positive}") # Извежда: int('+100') = 100

invalid_str = "3.14"
# int(invalid_str) # Ще генерира ValueError

another_invalid_str = "hello"
# int(another_invalid_str) # Ще генерира ValueError

	Специфициране на основата (base) на числото в низ:
 Функцията int() може да приеме втори необязателен аргумент - base. Този аргумент указва основата на системата, в която е представено числото в низа. По подразбиране основата е 10. Можете да преобразувате низове, представящи числа в двоична (base=2), осмична (base=8) или шестнадесетична (base=16) бройна система.
binary_str = "101101"
decimal_from_binary = int(binary_str, 2)
print(f"int('{binary_str}', 2) = {decimal_from_binary}") # Извежда: int('101101', 2) = 45

octal_str = "75"
decimal_from_octal = int(octal_str, 8)
print(f"int('{octal_str}', 8) = {decimal_from_octal}")   # Извежда: int('75', 8) = 61

hex_str_lower = "a3f"
decimal_from_hex_lower = int(hex_str_lower, 16)
print(f"int('{hex_str_lower}', 16) = {decimal_from_hex_lower}") # Извежда: int('a3f', 16) = 2623

hex_str_upper = "B9"
decimal_from_hex_upper = int(hex_str_upper, 16)
print(f"int('{hex_str_upper}', 16) = {decimal_from_hex_upper}") # Извежда: int('B9', 16) = 185

hex_str_with_prefix = "0xFF" # Python също така разбира префиксите 0b, 0o, 0x
decimal_from_hex_prefix = int(hex_str_with_prefix, 16)
print(f"int('{hex_str_with_prefix}', 16) = {decimal_from_hex_prefix}") # Извежда: int('0xFF', 16) = 255

	От цяло число (int): 
При преобразуване на цяло число към float, то се представя като десетично число с нулева дробна част.
int_num = 10
float_from_int = float(int_num)
print(f"float({int_num}) = {float_from_int}")   # Извежда: float(10) = 10.0
print(type(float_from_int))              # Извежда: <class 'float'>

	От низ (str) към число с плаваща запетая: 
Когато преобразувате низ към число с плаваща запетая, низът трябва да представлява валидно десетично число. Той може да съдържа водещи и завършващи интервали, необязателен знак (+ или -), както и десетична точка (.). Възможно е също така низът да бъде в експоненциална нотация (например "3.14e-5").
valid_float_str = "  -3.14159  "
float_from_str = float(valid_float_str)
print(f"float('{valid_float_str}') = {float_from_str}") # Извежда: float('  -3.14159  ') = -3.14159

positive_float_str = "+2.718"
float_from_positive = float(positive_float_str)
print(f"float('{positive_float_str}') = {float_from_positive}") # Извежда: float('+2.718') = 2.718

exponential_str_lower = "1.602e-19"
float_from_exp_lower = float(exponential_str_lower)
print(f"float('{exponential_str_lower}') = {float_from_exp_lower}") # Извежда: float('1.602e-19') = 1.602e-19

exponential_str_upper = "6.626E-34"
float_from_exp_upper = float(exponential_str_upper)
print(f"float('{exponential_str_upper}') = {float_from_exp_upper}") # Извежда: float('6.626E-34') = 6.626e-34

invalid_float_str = "hello"
# float(invalid_float_str) # Ще генерира ValueError

	Специални низови стойности: 
Функцията float() може също така да разпознае специални низови стойности, представляващи безкрайност ("inf" или "-inf") и "не е число" ("nan"). Тези стойности са case-insensitive.
infinity_positive_str = "inf"
positive_infinity = float(infinity_positive_str)
print(f"float('{infinity_positive_str}') = {positive_infinity}") # Извежда: float('inf') = inf

infinity_negative_str = "-Inf"
negative_infinity = float(infinity_negative_str)
print(f"float('{infinity_negative_str}') = {negative_infinity}") # Извежда: float('-Inf') = -inf

nan_str_lower = "nan"
not_a_number = float(nan_str_lower)
print(f"float('{nan_str_lower}') = {not_a_number}")       # Извежда: float('nan') = nan

nan_str_upper = "NaN"
another_not_a_number = float(nan_str_upper)
print(f"float('{nan_str_upper}') = {another_not_a_number}") # Извежда: float('NaN') = nan

	str() - Преобразуване към низ
Функцията str() се използва за преобразуване на стойности от всякакъв тип данни в техния строков (текстов) еквивалент. Това е изключително полезно за показване на данни на потребителя, записване във файлове или за комбиниране на различни типове данни в един низ.
	От числови типове (int, float): 

При преобразуване на числа към низ, те се представят в стандартния си десетичен вид.
integer_num = 123
str_from_int = str(integer_num)
print(f"str({integer_num}) = '{str_from_int}'")   # Извежда: str(123) = '123'
print(type(str_from_int))                         # Извежда: <class 'str'>

float_num = 3.14159
str_from_float = str(float_num)
print(f"str({float_num}) = '{str_from_float}'")   # Извежда: str(3.14159) = '3.14159'
print(type(str_from_float))                         # Извежда: <class 'str'>

negative_float = -2.718
str_from_neg_float = str(negative_float)
print(f"str({negative_float}) = '{str_from_neg_float}'") # Извежда: str(-2.718) = '-2.718'

	От булев тип (bool): 
Булевите стойности True и False се преобразуват съответно в низовете "True" и "False".
true_bool = True
str_from_true = str(true_bool)
print(f"str({true_bool}) = '{str_from_true}'")     # Извежда: str(True) = 'True'
print(type(str_from_true))                          # Извежда: <class 'str'>

false_bool = False
str_from_false = str(false_bool)
print(f"str({false_bool}) = '{str_from_false}'")   # Извежда: str(False) = 'False'
print(type(str_from_false))                # Извежда: <class 'str'>

	От списъци (list), кортежи (tuple), речници (dict) и множества (set) 
Когато преобразувате тези структури от данни към низ, те се представят във формата, в който биха били написани в кода на Python.
my_list = [1, 2, 3]
str_from_list = str(my_list)
print(f"str({my_list}) = '{str_from_list}'")       # Извежда: str([1, 2, 3]) = '[1, 2, 3]'
print(type(str_from_list))                         # Извежда: <class 'str'>

my_tuple = (4, 5, 6)
str_from_tuple = str(my_tuple)
print(f"str({my_tuple}) = '{str_from_tuple}'")     # Извежда: str((4, 5, 6)) = '(4, 5, 6)'
print(type(str_from_tuple))                         # Извежда: <class 'str'>

my_dict = {'a': 1, 'b': 2}
str_from_dict = str(my_dict)
print(f"str({my_dict}) = '{str_from_dict}'")       # Извежда: str({'a': 1, 'b': 2}) = "{'a': 1, 'b': 2}"
print(type(str_from_dict))                         # Извежда: <class 'str'>

my_set = {7, 8, 9}
str_from_set = str(my_set)
print(f"str({my_set}) = '{str_from_set}'")         # Извежда: str({8, 9, 7}) = '{8, 9, 7}' (редът може да варира)
print(type(str_from_set))                           # Извежда: <class 'str'>

	От други обекти: 
Функция str() може да бъде извикана върху обекти от дефинирани от потребителя класове. По подразбиране, тя ще върне низ, съдържащ информация за типа на обекта и неговия адрес в паметта. Можете да предефинирате специалния метод __str__ във вашия клас, за да контролирате как обектът ще бъде представен като низ при използване на str().

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Person(name='{self.name}', age={self.age})"

person1 = Person("Алиса", 30)
str_from_person = str(person1)
print(f"str({person1}) = '{str_from_person}'")   # Извежда: str(<__main__.Person object at 0x...>) (ако __str__ не е дефиниран)
                                                  # Извежда: str(person1) = 'Person(name='Алиса', age=30)' (ако __str__ е дефиниран)
print(type(str_from_person))     

Функцията str() е фундаментална за преобразуване на данни в текстов вид, което е често необходимо за извеждане, записване или обработка на информация.

Казус 1: Валидиране на потребителски вход за възраст
Напишете програма, която приема потребителски вход за възраст (като низ). Програмата трябва да валидира входът, като се увери, че може да бъде успешно преобразуван в цяло число и че възрастта е в разумен диапазон (например между 0 и 150 години). 
Решение:
age_str = input ("Моля, въведете вашата възраст: ")
age = int(age_str)
validate_age = age <= 150:
print (f"Възрастта ви е {age} {validate_age}")
        
Казус 2: Форматиране на лично съобщение
Създайте променливи за име на човек (низ) и брой на съобщения, които е изпратил (цяло число). Използвайте f-string, за да създадете и изведете съобщение във формат: "Здравей, [име]! Ти си изпратил [брой] съобщения."
Решение:
name = "Алиса"
message_count = 125

message = f"Здравей, {name}! Ти си изпратил {message_count} съобщения."
print(message)
 
Въпроси:
	Кои са основните примитивни типове данни в Python? Дайте пример за всеки от тях.
	Каква е разликата между int и float в Python?
	Какво представляват низовете в Python? Как се създават?
	Обяснете концепцията за динамично типизиране в Python. Какви са нейните предимства и недостатъци?
	Какви са булевите стойности в Python и какви логически операции могат да се извършват с тях?
	Какво е "type casting" или преобразуване на типове в Python? Защо е необходимо?
	Обяснете как работи функцията int() при преобразуване на стойности от други типове (например float, str). Какво се случва при опит за преобразуване на невалиден низ към int? Възможно ли е да се преобразуват низове с различна бройна основа към int? Ако да, как?
	Обяснете как работи функцията float() при преобразуване на стойности от други типове (int, str). Какви специални низови стойности могат да бъдат преобразувани към float?
	Обяснете как работи функцията str() при преобразуване на стойности от примитивните типове данни (int, float, bool). Как се преобразуват структури от данни като списъци и речници към низ?
	Обяснете как работи функцията bool() при преобразуване на стойности от други типове. Кои стойности се преобразуват до False?
Задачи:
	Създайте променлива, съдържаща цяло число, друга - с десетично число, трета - с низ и четвърта - с булева стойност. Изведете типа на всяка променлива.
	Напишете код, който оперира с две променливи със стойности избрани от вас числа и извежда техния сбор, разлика, произведение и частно (ако е възможно).
	Създайте низ "Python е мощен език". Изведете дължината на низа, първия и последния му символ. Извлечете подниза "мощен език".
	Дадени са две булеви променливи a = True и b = False. Изведете резултата от a and b, a or b и not a.
	Напишете код, който проверява дали дадено число е по-голямо от 10 и по-малко от 20 едновременно. Изведете булев резултат.
	Напишете код, който приема десетично число като низ (например "3.14") и го преобразува към float. Изведете резултата и неговия тип. 
	  Напишете код, който приема цяло число и го преобразува към двоичен, осмичен и шестнадесетичен низ. Изведете резултатите. 
	  Напишете код, който приема булева стойност и я преобразува към низ. Изведете резултата и неговия тип. 
	 Напишете код, който приема низ, представляващ цяло число в двоична система (например "1101"), и го преобразува към десетично цяло число. Изведете резултата.
	Напишете код, който приема число (цяло или десетично) и го преобразува към булева стойност. Експериментирайте с различни числа (включително 0 и отрицателни) и обяснете резултатите.



	Основни типове данни в Python (част 2: Структури от данни)
 
В езика за програмиране Python, освен основните примитивни типове данни, които разгледахме по-рано (числа, низове, булеви стойности), съществуват и по-сложни типове данни, наречени структури от данни. Тези структури са изключително важни, тъй като ни позволяват да организираме и управляваме колекции от данни по ефективен начин.
Типовете данни играят ключова роля в програмирането, защото определят каква информация може да бъде съхранявана и какви операции могат да бъдат извършвани с нея. Изборът на подходяща структура от данни може значително да повлияе на производителността и четимостта на вашия код.
Python предлага няколко вградени структури от данни, всяка от които има свои специфични характеристики и е оптимизирана за различни видове задачи. В тази част ще се запознаем с основните от тях:
	Списъци (Lists): Подредени, изменяеми колекции от елементи.
	Кортежи (Tuples): Подредени, неизменяеми колекции от елементи.
	Речници (Dictionaries): Неподредени колекции от двойки ключ-стойност.
	Множества (Sets): Неподредени колекции от уникални елементи.
В следващите подточки ще разгледаме всяка от тези структури по-подробно, ще видим как се създават, какви операции могат да се извършват с тях и кога е подходящо да се използват.
	Списъци (Lists)
Списъците са една от най-гъвкавите и често използвани структури от данни в Python. Те представляват подредени колекции от елементи, което означава, че елементите се съхраняват в определен ред и този ред се запазва. Една от ключовите характеристики на списъците е, че те са изменяеми (mutable), което позволява да добавяте, премахвате или променяте елементи след създаването на списъка. Списъците могат да съдържат елементи от различни типове данни (цели числа, десетични числа, низове, булеви стойности, дори други списъци или други структури от данни). 





	Създаване на списъци:
Списъците се създават, като елементите се поставят в квадратни скоби [] и се разделят със запетаи.
# Създаване на празен списък
empty_list = []
print(f"Празен списък: {empty_list}")

# Списък с цели числа
numbers = [1, 2, 3, 4, 5]
print(f"Списък с числа: {numbers}")

# Списък с низове
fruits = ["ябълка", "банан", "череша"]
print(f"Списък с плодове: {fruits}")

# Списък със смесени типове данни
mixed_data = [1, "hello", 3.14, True]
print(f"Списък със смесени данни: {mixed_data}")

# Вложен списък (списък, съдържащ друг списък)
nested_list = [1, [2, 3], 4]
print(f"Вложен списък: {nested_list}")

	Достъпване на елементи (индексиране):
Тъй като списъците са подредени, достъпът до отделните елементи се осъществява чрез техния индекс. Индексирането в Python започва от 0 за първия елемент, 1 за втория и така нататък. Може да се използва и отрицателно индексиране, където -1 е последният елемент, -2 е предпоследният и т.н.
fruits = ["ябълка", "банан", "череша"]

# Достъпване по положителен индекс
first_fruit = fruits[0]
print(f"Първият плод е: {first_fruit}")  # Извежда: Първият плод е: ябълка

second_fruit = fruits[1]
print(f"Вторият плод е: {second_fruit}") # Извежда: Вторият плод е: банан

last_fruit = fruits[2]
print(f"Третият плод е: {last_fruit}")  # Извежда: Третият плод е: череша

# Достъпване по отрицателен индекс
last_fruit_negative = fruits[-1]
print(f"Последният плод (отрицателен индекс) е: {last_fruit_negative}") # Извежда: Последният плод (отрицателен индекс) е: череша

second_to_last_fruit = fruits[-2]
print(f"Предпоследният плод е: {second_to_last_fruit}") # Извежда: Предпоследният плод е: банан
	!!!ВАЖНО!!! Опитът за достъп до индекс, който е извън границите на списъка, ще доведе до грешка IndexError.



	Добавяне на елементи:
Python предоставя няколко начина за добавяне на елементи към списък:

	.append(element): Добавя element в края на списъка.
my_list = [1, 2, 3]
my_list.append(4)
print(my_list)        # Извежда: [1, 2, 3, 4]

	extend(iterable): Добавя всички елементи от iterable (например друг списък, кортеж или низ) в края на текущия списък.
my_list.extend([5, 6])
print(my_list)        # Извежда: [1, 2, 3, 4, 5, 6]

	.insert(index, element): вмъква element на дадена index позиция
my_list.insert(0, 0)
print(my_list)        # Извежда: [0, 1, 2, 3, 4, 5, 6]

	Премахване на елементи:
Съществуват няколко начина за премахване на елементи от списък:

	.remove(element): Премахва първото срещане на указания element от списъка. Ако елементът не бъде намерен, се генерира грешка ValueError.
my_list.remove(3)
print(my_list)        # Извежда: [0, 1, 2, 4, 5, 6]

	.pop(index): Премахва и връща елемента на указания index. Ако index не е указан, .pop() премахва и връща последния елемент от списъка.
my_list = [0, 2, 4, 5, 6]
popped_element_at_index = my_list.pop(1)
print(popped_element_at_index) # Извежда: 2
print(my_list)                # Извежда: [0, 4, 5, 6]

another_list = [10, 20, 30]
last_element = another_list.pop() # Без указан индекс
print(last_element)             # Извежда: 30
print(another_list)             # Извежда: [10, 20]

	Слайсиране на списъци:
Слайсирането е мощен начин за достъп до подмножества (подсписъци) от списък. То ви позволява да извличате последователности от елементи, като указвате начален и краен индекс (и опционално стъпка). Синтаксисът за слайсиране е [start:end:step].
	start (начален индекс): Индексът, от който започва слайсът. Ако е пропуснат, се приема началото на списъка (индекс 0).
	end (краен индекс): Индексът, до който достига слайсът (елементът на този индекс не е включен). Ако е пропуснат, се приема края на списъка.
	step (стъпка): Определя стъпката (интервала) между елементите в слайса. Ако е пропуснат, се приема стъпка 1 (всички елементи в диапазона).

numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

# Извличане на елементи от индекс 2 до 5 (без 5)
sub_list1 = numbers[2:5]
print(sub_list1)  # Извежда: [2, 3, 4]

# Извличане на елементи от началото до индекс 3 (без 3)
sub_list2 = numbers[:3]
print(sub_list2)  # Извежда: [0, 1, 2]

# Извличане на елементи от индекс 6 до края
sub_list3 = numbers[6:]
print(sub_list3)  # Извежда: [6, 7, 8, 9]

# Извличане на всички елементи с стъпка 2
sub_list4 = numbers[::2]
print(sub_list4)  # Извежда: [0, 2, 4, 6, 8]

# Извличане на елементи от индекс 1 до 7 с стъпка 3
sub_list5 = numbers[1:7:3]
print(sub_list5)  # Извежда: [1, 4]

# Използване на отрицателни индекси
sub_list6 = numbers[-3:]
print(sub_list6)  # Извежда: [7, 8, 9] (последните три елемента)

sub_list7 = numbers[:-2]
print(sub_list7)  # Извежда: [0, 1, 2, 3, 4, 5, 6, 7] (всички елементи освен последните два)

# Обръщане на списък с помощта на стъпка -1
reversed_list = numbers[::-1]
print(reversed_list) # Извежда: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]

Слайсирането създава нов списък, който е копие на указаната част от оригиналния списък. Оригиналният списък остава непроменен.
Слайсирането е изключително полезно за извличане на конкретни подмножества от данни от списъци, без да се налага да се итерира през тях ръчно. То е често използван инструмент при обработката на данни в Python.
	Методи на списъци:
Списъците в Python са обекти, които имат вградени методи, позволяващи да се извършват различни операции върху тях. Тези методи предоставят удобен и ефективен начин за добавяне, премахване, търсене и манипулиране на елементи в списъка. Ето някои от най-често използваните методи:
	.append(element) (Добавя element в края на списъка.)
	.extend(iterable) (Добавя всички елементи от iterable (например друг списък, кортеж или низ) в края на текущия списък.)
	.remove(element)( Премахва първото срещане на element от списъка. Ако елементът не съществува, се генерира грешка ValueError.) 
	.pop(index) (Премахва и връща елемента на указания index. Ако index не е указан, .pop() премахва и връща последния елемент от списъка.)
	.insert(index, element) (Вмъква element на дадена index позиция. Елементите след тази позиция се изместват надясно.)
	.count(element) (Връща броя на срещанията на element в списъка.)
numbers = [1, 2, 2, 3, 2, 4]
count_of_2 = numbers.count(2)
print(count_of_2)  # Извежда: 3

	.reverse() (Обръща реда на елементите в списъка на място (променя оригиналния списък)

letters = ["a", "b", "c", "d"]
letters.reverse()
print(letters)  # Извежда: ['d', 'c', 'b', 'a']

	.index(element, start, end) (Връща индекса на първото срещане на element в списъка (или в поддиапазон, ако са указани start и end). Ако елементът не бъде намерен, се генерира грешка ValueError.)
letters = ["a", "b", "c", "b", "d"]
print(letters.index("b"))      # Извежда: 1
print(letters.index("b", 2))  # Извежда: 3 (търсене започва от индекс 2) 
print(letters.index("e"))    # Ще генерира ValueError

	.sort()
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
numbers.sort()
print(numbers)  # Извежда: [1, 1, 2, 3, 4, 5, 6, 9]

	.sort(key=..., reverse=False) (Сортира елементите на списъка на място (променя оригиналния списък). По подразбиране сортира във възходящ ред. key може да бъде функция, която се прилага към всеки елемент преди сравнение, а reverse=True сортира в низходящ ред.)
fruits = ["банан", "ябълка", "киви"]
fruits.sort(reverse=True)
print(fruits)   # Извежда: ['ябълка', 'киви', 'банан']

	sorted(iterable, key=..., reverse=False) (Вградена функция, която връща нов сортиран списък от елементите на iterable (например друг списък, кортеж). Оригиналният iterable остава непроменен.) 
words = ["алабала", "котка", "слон"]
words.sort(key=len) # Сортиране по дължина на думата
print(words)    # Извежда: ['котка', 'слон', 'алабала']
numbers = [3, 1, 4, 1, 5, 9, 2, 6]
sorted_numbers = sorted(numbers)
print(sorted_numbers)  # Извежда: [1, 1, 2, 3, 4, 5, 6, 9]
print(numbers)         # Извежда: [3, 1, 4, 1, 5, 9, 2, 6] (оригиналният не е променен)

	copy(): Връща плитко копие на списъка.

original_list = [1, 2, [3, 4]]
copied_list = original_list.copy()

# Промяна на елемент от първо ниво
copied_list[0] = 10
print(copied_list)    # Извежда: [10, 2, [3, 4]]
print(original_list)  # Извежда: [1, 2, [3, 4]] (първото ниво не е засегнато)

# Промяна на елемент във вложения списък
copied_list[2][0] = 30
print(copied_list)    # Извежда: [10, 2, [30, 4]]
print(original_list)  # Извежда: [1, 2, [30, 4]] (вложеното ниво е засегнато)

import copy
deep_copied_list = copy.deepcopy(original_list)
deep_copied_list[2][1] = 40
print(deep_copied_list) # Извежда: [1, 2, [30, 40]]
print(original_list)  # Извежда: [1, 2, [30, 4]] (оригиналният не е засегнат)


	clear(): Премахва всички елементи от списъка, правейки го празен. 

original_list = [1, 2, [3, 4]]
copied_list = original_list.copy()
# Промяна на елемент от първо ниво
copied_list[0] = 10
print(copied_list)    # Извежда: [10, 2, [3, 4]]
print(original_list)  # Извежда: [1, 2, [3, 4]] (първото ниво не е засегнато)
# Промяна на елемент във вложения списък
copied_list[2][0] = 30
print(copied_list)    # Извежда: [10, 2, [30, 4]]
print(original_list)  # Извежда: [1, 2, [30, 4]] (вложеното ниво е засегнато)

import copy
deep_copied_list = copy.deepcopy(original_list)
deep_copied_list[2][1] = 40
print(deep_copied_list) # Извежда: [1, 2, [30, 40]]
print(original_list)  # Извежда: [1, 2, [30, 4]] (оригиналният не е засегнат)
	Разбирането и използването на тези методи е ключово за ефективната работа със списъци в Python. Те предоставят удобни начини за манипулиране на колекции от данни.



	Кортежи (Tuples)
Кортежите са друга основна структура от данни в Python, която много прилича на списъците. Те също представляват подредени последователности от елементи, което означава, че редът на елементите е важен и се запазва. Една от ключовите и съществени разлики между списъците и кортежите е, че кортежите са неизменяеми (immutable). Това означава, че след като бъде създаден един кортеж, вие не можете да променяте неговите елементи - не можете да добавяте, премахвате или заменяте елементи.
Кортежите се дефинират чрез поставяне на елементи в кръгли скоби (...), разделени със запетаи. Въпреки че скобите могат да бъдат пропуснати в някои случаи (например при създаване на кортеж с множество елементи), е добра практика да се използват за по-голяма яснота, особено когато кортежът съдържа един елемент (където запетаята след елемента е задължителна, за да се разграничи от обикновен скалар в скоби).
Поради своята неизменяемост, кортежите имат някои предимства в определени ситуации:
	Защита на данните: Неизменяемостта гарантира, че данните в кортежа остават константни през целия живот на програмата.
	Използване като ключове в речници: Тъй като са неизменяеми и хешируеми, кортежите могат да се използват като ключове в речници (за разлика от списъците).
	Производителност: В някои случаи, операциите с кортежи могат да бъдат малко по-бързи от тези със списъци.
В следващите подточки ще разгледаме как се създават кортежи и какви основни операции могат да бъдат извършвани с тях.
	Създаване на кортежи:
Кортежите се създават чрез поставяне на елементи, разделени със запетаи, в кръгли скоби (...). Въпреки това, скобите не винаги са задължителни, особено при създаване на кортеж с множество елементи. За кортеж с един елемент обаче, е задължително да поставите запетая след елемента, за да го разграничите от обикновена стойност в скоби.
# Празен кортеж
empty_tuple = ()
print(empty_tuple)          # Извежда: ()
print(type(empty_tuple))    # Извежда: <class 'tuple'>

# Кортеж с един елемент (задължителна запетая)
single_item_tuple = (5,)
print(single_item_tuple)            # Извежда: (5,)
print(type(single_item_tuple))  # Извежда: <class 'tuple'>

not_a_tuple = (5)
print(not_a_tuple)          # Извежда: 5
print(type(not_a_tuple))    # Извежда: <class 'int'>
# Кортеж с множество елементи (скобите са препоръчителни за яснота)
integer_tuple = (1, 2, 3, 4, 5)
string_tuple = ("ябълка", "банан", "череша")
mixed_tuple = (1, "hello", 3.14, True)

print(integer_tuple)
print(string_tuple)
print(mixed_tuple)

# Създаване на кортеж без скоби (tuple packing)
another_tuple = 10, 20, "world"
print(another_tuple)     # Извежда: (10, 20, 'world')
print(type(another_tuple)) # Извежда: <class 'tuple'>

	Основни операции (неизменяемост):
След като бъде създаден, кортежът е неизменяем. Това означава, че не можете да:
	Променяте стойността на съществуващ елемент.
	Добавяте нови елементи.
	Премахвате съществуващи елементи.
Ако се опитате да извършите някоя от тези операции, ще получите грешка TypeError.
my_tuple = (1, 2, 3)

my_tuple[0] = 10  # Ще генерира TypeError: 'tuple' object does not support item assignment
del my_tuple[1]  # Ще генерира TypeError: 'tuple' object doesn't support item deletion
my_tuple.append(4) # Ще генерира AttributeError: 'tuple' object has no attribute 'append'

Въпреки своята неизменяемост, можете да извършвате следните основни операции с кортежи:
	Достъп до елементи (индексиране): Както при списъците, можете да достъпвате елементи по техния индекс (започващ от 0).
my_tuple = ('a', 'b', 'c')
print(my_tuple[0])   # Извежда: a
print(my_tuple[2])   # Извежда: c
print(my_tuple[-1])  # Извежда: c


	Слайсиране: Можете да извличате подкортежи, като използвате нотацията за слайсиране [start:end:step]. Резултатът от слайсирането е нов кортеж.
my_tuple = (10, 20, 30, 40, 50)
sub_tuple = my_tuple[1:4]
print(sub_tuple)    # Извежда: (20, 30, 40)
print(my_tuple[:2])   # Извежда: (10, 20)
print(my_tuple[::2])  # Извежда: (10, 30, 50)

	Конкатенация (+): Можете да съединявате два или повече кортежа, за да създадете нов кортеж.
tuple1 = (1, 2)
tuple2 = (3, 4)
combined_tuple = tuple1 + tuple2
print(combined_tuple) # Извежда: (1, 2, 3, 4)


	Повтаряне (*): Можете да повторите елементите на кортеж няколко пъти, за да създадете нов кортеж.
my_tuple = ('a', 'b') repeated_tuple = my_tuple * 3 print(repeated_tuple) # Извежда: ('a', 'b', 'a', 'b', 'a', 'b')

	len(): Вградената функция len() връща броя на елементите в кортежа.
my_tuple = (1, 2, 3, 4)
print(len(my_tuple))  # Извежда: 4
print(len(my_tuple))  # Извежда: 4

	count(): Метод, който връща броя на срещанията на даден елемент в кортежа.
my_tuple = (1, 2, 2, 3, 2)
count_of_2 = my_tuple.count(2)
print(count_of_2)  # Извежда: 3

	index(): Метод, който връща индекса на първото срещане на даден елемент в кортежа.
my_tuple = ('x', 'y', 'z', 'y')
index_of_y = my_tuple.index('y')
print(index_of_y)  # Извежда: 1
	Разбирането на неизменяемостта на кортежите е ключово. Те се използват, когато искате да гарантирате, че последователността от елементи няма да бъде променяна случайно по време на изпълнението на програмата.

	Речници (Dictionaries)
Речниците са друга фундаментална структура от данни в Python. За разлика от списъците и кортежите, които са подредени последователности от елементи, речниците са неподредени колекции от двойки ключ-стойност. Всеки ключ в речника е уникален и се използва за достъп до съответната стойност. Речниците са изключително полезни, когато искате да съхранявате и извличате данни по асоциативен начин, използвайки смислени ключове вместо числови индекси.
Представете си речник като обикновен езиков речник, където всяка дума (ключ) има свое определение (стойност). По същия начин, в Python речниците, вие асоциирате ключове със стойности.
Речниците се дефинират чрез поставяне на двойки ключ-стойност в къдрави скоби {}, като всяка двойка е във формата ключ: стойност, а отделните двойки са разделени със запетаи. Ключовете трябва да бъдат неизменяеми типове данни (например низове, числа, кортежи), докато стойностите могат да бъдат от всякакъв тип данни (включително други речници, списъци и т.н.).
Речниците са изменяеми, което означава, че можете да добавяте нови двойки ключ-стойност, да променяте стойностите на съществуващи ключове и да премахвате двойки ключ-стойност след създаването на речника.
В следващите подточки ще разгледаме как се създават речници и какви основни операции могат да бъдат извършвани с тях.
	Създаване на речници:
Речниците могат да бъдат създадени по няколко начина:
	Използване на къдрави скоби {}: 
Можете да създадете речник, като поставите двойки ключ-стойност вътре в къдрави скоби, разделени със запетаи. Всяка двойка ключ-стойност се състои от ключ, следван от двоеточие :, последван от стойността.

empty_dict = {}
person = {"name": "Алиса", "age": 30, "city": "София"}
car = {"brand": "Toyota", "model": "Corolla", "year": 2022}

print(empty_dict) # Извежда: {}
print(person)     # Извежда: {'name': 'Алиса', 'age': 30, 'city': 'София'}
print(car)  # Извежда: {'brand': 'Toyota', 'model': 'Corolla', 'year': 2022}

print(type(person))    # Извежда: <class 'dict'>
print(type(person))    # Извежда: <class 'dict'>

	Използване на вградената функция dict(): 
Функцията dict() може да бъде използвана за създаване на речник от други структури от данни, като например списъци от двойки (ключ, стойност) или ключови аргументи.
# От списък от кортежи
items = [("apple", 1), ("banana", 2), ("cherry", 3)]
fruit_counts = dict(items)
print(fruit_counts)    # Извежда: {'apple': 1, 'banana': 2, 'cherry': 3}

# Чрез ключови аргументи (ключовете трябва да са валидни Python идентификатори)
student = dict(name="Борис", grade=10, average_score=5.5)
print(student)         # Извежда: {'name': 'Борис', 'grade': 10, 'average_score': 5.5}

	Използване на разбивания на речници (dictionary comprehensions): 
Подобно на разбиванията на списъци, можете да създавате речници по елегантен начин, използвайки разбивания.
numbers = [1, 2, 3, 4, 5]
squared_numbers = {number: number**2 for number in numbers}
print(squared_numbers) # Извежда: {1: 1, 2: 4, 3: 9, 4: 16, 5: 25}

names = ["Alice", "Bob", "Charlie"]
name_lengths = {name: len(name) for name in names}
print(name_lengths)    # Извежда: {'Alice': 5, 'Bob': 3, 'Charlie': 7}
print(name_lengths)    # Извежда: {'Alice': 5, 'Bob': 3, 'Charlie': 7}

	Важни характеристики при създаване на речници:
	Уникалност на ключовете: Всеки ключ в речника трябва да бъде уникален. Ако се опитате да използвате един и същ ключ повече от веднъж при създаването на речника (или при добавяне на нов елемент), по-късната стойност ще презапише по-ранната.
example = {"a": 1, "b": 2, "a": 3}
print(example)  # Извежда: {'a': 3, 'b': 2} (стойността за 'a' е презаписана)

	Неизменяемост на ключовете: Ключовете в речника трябва да бъдат от неизменяем тип данни, като низове, числа или кортежи. Списъците не могат да бъдат използвани като ключове, тъй като са изменяеми. Стойностите в речника могат да бъдат от всякакъв тип.
valid_key_tuple = (1, 2)
my_dict = {valid_key_tuple: "value"}
print(my_dict)       # Извежда: {(1, 2): 'value'}

invalid_key_list = [1, 2]
another_dict = {invalid_key_list: "value"} # Ще генерира TypeError: unhashable type: 'list'
Разбирането на тези начини за създаване на речници е първата стъпка към ефективната им употреба. В следващата подглава ще разгледаме как можем да достъпваме и манипулираме елементи в речниците.
	Достъпване, добавяне и премахване на ключове и стойности:
След като сте създали речник, е важно да знаете как да достъпвате съхранените в него стойности, както и как да добавяте нови двойки ключ-стойност и да премахвате съществуващи.
	Достъпване на стойности: 
	Стойностите в речника се достъпват по техния ключ, като се използва нотацията с квадратни скоби [].

person = {"name": "Алиса", "age": 30, "city": "София"}
name = person["name"]
age = person["age"]
print(f"Името е: {name}")   # Извежда: Името е: Алиса
print(f"Възрастта е: {age}") # Извежда: Възрастта е: 30
# Опит за достъп до несъществуващ ключ ще генерира KeyError
city = person["country"] # Ще генерира KeyError: 'country'

За да избегнете грешка KeyError при опит за достъп до ключ, който може да не съществува, можете да използвате метода .get(key, default):

	За да добавите нова двойка ключ-стойност към речник, просто присвоете стойност на нов ключ, използвайки нотацията с квадратни скоби.
	Промяна на стойността на съществуващ ключ: 
За да промените стойността, свързана със съществуващ ключ, достъпете ключа и му присвоете нова стойност.

	Премахване на двойки ключ-стойност: 
Има няколко начина за премахване на елементи от речник:

	del оператор: Използва се за изтриване на елемент по неговия ключ. Ако ключът не съществува, се генерира грешка KeyError.
person = {"name": "Алиса", "age": 30, "city": "София"}
person["age"] = 31
print(person) # Извежда: {'name': 'Алиса', 'age': 31, 'city': 'София'}

	Метод .pop(key, default): Премахва и връща стойността, свързана с указания key. Ако ключът не съществува, се връща стойността на default (ако е зададена) или се генерира грешка KeyError (ако default не е зададена).
phone = {"make": "Samsung", "model": "Galaxy", "price": 800}
price = phone.pop("price")
print(f"Премахната цена: {price}") # Извежда: Премахната цена: 800
print(phone)            # Извежда: {'make': 'Samsung', 'model': 'Galaxy'}

color = phone.pop("color", "няма информация")

	Метод .popitem(): Премахва и връща последната добавена двойка ключ-стойност като кортеж (key, value). В версии на Python преди 3.7, редът на елементите в речника не е гарантиран, така че .popitem() би могъл да премахне произволен елемент.
my_dict = {"a": 1, "b": 2, "c": 3}
last_item = my_dict.popitem()
print(f"Премахнат елемент: {last_item}") # Извежда: ('c', 3) (или друг елемент в по-стари версии)
print(my_dict)                         # Извежда: {'a': 1, 'b': 2}

	Метод .clear(): Премахва всички елементи от речника, правейки го празен.
Разбирането на тези начини за достъпване, добавяне и премахване на елементи е от съществено значение за работата с речници в Python.
	Методи на речници:
Речниците в Python идват с набор от вградени методи, които улесняват достъпа до техните ключове, стойности и елементи, както и други полезни операции. Ето някои от най-често използваните методи:
	Метод .keys(): Връща обект от тип "view object", който показва списък на всички ключове в речника. Този обект се обновява динамично, ако речникът бъде променен. Можете да го преобразувате в истински списък, ако е необходимо, с помощта на list().
person = {"name": "Алиса", "age": 30, "city": "София"}
keys = person.keys()
print(keys)       # Извежда: dict_keys(['name', 'age', 'city'])
print(list(keys)) # Извежда: ['name', 'age', 'city']

	Метод .values(): Връща обект от тип "view object", който показва списък на всички стойности в речника. Подобно на .keys(), този обект се обновява динамично.
person = {"name": "Алиса", "age": 30, "city": "София"}
values = person.values()
print(values)       # Извежда: dict_values(['Алиса', 30, 'София'])
print(list(values)) # Извежда: ['Алиса', 30, 'София']

	Метод .items(): Връща обект от тип "view object", който показва списък от всички двойки (ключ, стойност) в речника като кортежи. Отново, обновява се динамично.
person = {"name": "Алиса", "age": 30, "city": "София"}
items = person.items()
print(items)        # Извежда: dict_items([('name', 'Алиса'), ('age', 30), ('city', 'София')])
print(list(items))  # Извежда: [('name', 'Алиса'), ('age', 30), ('city', 'София')]

for key, value in person.items():
    print(f"{key}: {value}")
# Извежда:
# name: Алиса
# age: 30
# city: София

	.get(key, default): Връща стойността за указания key. Ако ключът не съществува, връща default (ако е зададена) или None. Вече го споменахме при достъпването, но е важен метод.
person = {"name": "Алиса", "age": 30}
name = person.get("name")    # Извежда: Алиса
country = person.get("country") # Извежда: None
country_default = person.get("country", "България") # Извежда: България

	.update(other_dict): Добавя всички двойки ключ-стойност от other_dict към текущия речник. Ако ключ съществува и в двата речника, стойността в текущия речник се обновява със стойността от other_dict. Може да се използва и с итерируем обект от двойки (ключ, стойност) или с ключови аргументи.
dict1 = {"a": 1, "b": 2}
dict2 = {"b": 3, "c": 4}
dict1.update(dict2)
print(dict1)      # Извежда: {'a': 1, 'b': 3, 'c': 4} ('b' е обновен, 'c' е добавен)

dict3 = {"x": 10}
dict3.update([("y", 20), ("z", 30)])
print(dict3)      # Извежда: {'x': 10, 'y': 20, 'z': 30}

dict4 = {"p": 100}
dict4.update(q=200, r=300)
print(dict4)      # Извежда: {'p': 100, 'q': 200, 'r': 300}

	.setdefault(key, default): Ако key съществува в речника, връща неговата стойност. Ако не съществува, вмъква key със стойност default и връща default. Ако default не е указана, се приема None.
my_dict = {"name": "Елена", "age": 25}
age = my_dict.setdefault("age", 30)
print(f"Възраст: {age}")      # Извежда: Възраст: 25 (ключът съществува)
print(my_dict)              # Извежда: {'name': 'Елена', 'age': 25}

city = my_dict.setdefault("city", "Варна")
print(f"Град: {city}")       # Извежда: Град: Варна (ключът не съществува, добавен е)
print(my_dict)              # Извежда: {'name': 'Елена', 'age': 25, 'city': 'Варна'}

	.copy(): Връща плитко копие на речника. Подобно на копирането на списъци, промените в стойностите, които са изменяеми обекти, ще се отразят и в оригинала и в копието.
original_dict = {"a": 1, "b": [2, 3]}
copied_dict = original_dict.copy()

copied_dict["a"] = 10
copied_dict["b"][0] = 20
print(copied_dict)    # Извежда: {'a': 10, 'b': [20, 3]}
print(original_dict)  # Извежда: {'a': 1, 'b': [20, 3]} (вложеният списък е променен)

	.copy(): Връща плитко копие на речника. Подобно на копирането на списъци, промените в стойностите, които са изменяеми обекти, ще се отразят и в оригинала и в копието.

	.pop(key, default): Премахва и връща стойността за указания key. Ако ключът не съществува, връща default (ако е зададена) или генерира KeyError. Вече го споменахме при премахването.
	.popitem(): Премахва и връща последната добавена двойка (ключ, стойност) като кортеж. В Python версии преди 3.7, редът не е гарантиран. Вече го споменахме при премахването.
	.clear(): Премахва всички елементи от речника. Вече го споменахме при премахването.

	Разбирането на тези методи ви дава пълен контрол върху манипулирането на речници в Python.

	Множества (Sets)
Множествата са друга важна вградена структура от данни в Python. Те представляват неподредени колекции от уникални елементи. Това означава, че в едно множество не могат да съществуват дублиращи се стойности, и редът, в който са добавени елементите, не се запазва. Множествата са особено полезни за операции като премахване на дубликати от последователности, проверка за принадлежност, както и за изпълнение на стандартни математически операции с множества като обединение, сечение и разлика.
Множествата се дефинират чрез поставяне на елементи в къдрави скоби {}, разделени със запетаи. Въпреки това, за създаване на празно множество трябва да използвате функцията set(), тъй като празните къдрави скоби {} създават празен речник, а не празно множество.
Елементите в множеството трябва да бъдат от неизменяем тип данни (например числа, низове, кортежи). Множествата сами по себе си са изменяеми, което означава, че можете да добавяте и премахвате елементи от тях след създаването им.
В следващите подточки ще разгледаме как се създават множества и какви основни операции могат да бъдат извършвани с тях.

	Създаване на множества:
Множества могат да бъдат създадени по няколко начина:
	Използване на къдрави скоби {}: Можете да създадете множество, като поставите елементи вътре в къдрави скоби, разделени със запетаи. Важно е да се отбележи, че ако опитате да включите дублиращи се елементи, те автоматично ще бъдат премахнати и в множеството ще останат само уникалните стойности.
my_set = {1, 2, 3}
print(my_set)         # Извежда: {1, 2, 3}

another_set = {3, 1, 2, 1, 3}
print(another_set)    # Извежда: {1, 2, 3} (дубликатите са премахнати)

mixed_set = {1, "hello", 3.14, True}
print(mixed_set)     # Извежда: {1, 3.14, 'hello'} (редът може да е различен)

print(type(my_set))   # Извежда: <class 'set'>

	Използване на вградената функция set(): Функцията set() може да бъде използвана за създаване на множество от други итерируеми обекти, като например списъци, кортежи или низове. При създаване на множество от итерируем обект, всички дублиращи се елементи ще бъдат премахнати.
# От списък
my_list = [1, 2, 2, 3, 4, 4, 5]
set_from_list = set(my_list)
print(set_from_list)  # Извежда: {1, 2, 3, 4, 5}

# От низ (всеки символ става елемент на множеството)
my_string = "abracadabra"
set_from_string = set(my_string)
print(set_from_string) # Извежда: {'a', 'b', 'r', 'c', 'd'} (редът може да е различен)

# От кортеж
my_tuple = (10, 20, 20, 30)
set_from_tuple = set(my_tuple)
print(set_from_tuple) # Извежда: {10, 20, 30}

# Създаване на празно множество (задължително е да се използва set())
empty_set = set()
print(empty_set)        # Извежда: set()
print(type(empty_set))  # Извежда: <class 'set'>

# Грешно създаване на празно множество (създава празен речник)
not_a_set = {}
print(not_a_set)        # Извежда: {}
print(type(not_a_set))  # Извежда: <class 'dict'>

	Използване на разбирания на множества (set comprehensions): Подобно на разбиранията на списъци и речници, можете да създавате множества по елегантен начин, използвайки разбирания.

numbers = [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]
unique_squares = {number**2 for number in numbers}
print(unique_squares) # Извежда: {1, 4, 9, 16, 25}

words = ["hello", "world", "python", "hello"]
unique_lengths = {len(word) for word in words}
print(unique_lengths) # Извежда: {5, 7, 6}

	Важни характеристики при създаване на множества:
	Уникалност на елементите: Множествата автоматично премахват всички дублиращи се елементи.
	Неподреденост: Елементите в множеството нямат определен ред. При извеждане на множеството, елементите могат да се появят в различен ред от този, в който са били добавени.
	Неизменяемост на елементите: Елементите, които се добавят към множеството, трябва да бъдат от неизменяем тип данни (например числа, низове, кортежи). Списъците не могат да бъдат елементи на множество, тъй като са изменяеми.

	Разбирането на тези начини за създаване на множества е важна стъпка към тяхното ефективно използване. В следващата подглава ще разгледаме основните операции, които могат да се извършват с множества.
	Основни операции с множества:
Python предоставя богат набор от операции за работа с множества, включително добавяне и премахване на елементи, както и стандартни математически операции с множества.
	Добавяне на елементи:

	.add(element): Добавя element към множеството. Ако елементът вече съществува, множеството остава непроменено (тъй като множествата съдържат само уникални елементи).
my_set = {1, 2, 3}
my_set.add(4)
print(my_set)   # Извежда: {1, 2, 3, 4}
my_set.add(2)
print(my_set)   # Извежда: {1, 2, 3, 4} (няма промяна, 2 вече съществува)


	.update(iterable): Добавя всички елементи от iterable (например списък, кортеж или друго множество) към текущото множество. Дублиращите се елементи от iterable се игнорират.
set1 = {1, 2, 3}
list1 = [3, 4, 5]
set1.update(list1)
print(set1)     # Извежда: {1, 2, 3, 4, 5}

set2 = {10, 20}
tuple1 = (20, 30, 40)
set2.update(tuple1)
print(set2)     # Извежда: {10, 20, 30, 40}

	Премахване на елементи:

	.remove(element): Премахва element от множеството. Ако елементът не съществува, се генерира грешка KeyError.
my_set = {1, 2, 3}
my_set.remove(2)
print(my_set)   # Извежда: {1, 3}

my_set.remove(4) # Ще генерира KeyError: 4

	.discard(element): Премахва element от множеството, ако той съществува. Ако елементът не съществува, не се генерира грешка.

	pop(): Премахва и връща произволен елемент от множеството. Тъй като множествата са неподредени, няма гаранция кой елемент ще бъде премахнат. Ако множеството е празно, се генерира грешка KeyError.


my_set = {10, 20, 30, 40}
removed_element = my_set.pop()
print(f"Премахнат елемент: {removed_element}") # Извежда: (например) 40
print(my_set)                       # Извежда: (например) {10, 20, 30}

empty_set = set()
empty_set.pop() # Ще генерира KeyError: 'pop from empty set'

	clear(): Премахва всички елементи от множеството, правейки го празно.

my_set = {1, 2, 3}
my_set.clear()
print(my_set)   # Извежда: set()

	Математически операции с множества:

Python поддържа стандартните математически операции с множества:
	Обединение (Union): Връща ново множество, съдържащо всички уникални елементи от двете множества. Може да се извърши с оператора | или метода .union().
set1 = {1, 2, 3}
set2 = {3, 4, 5}
union_set = set1 | set2
print(union_set)    # Извежда: {1, 2, 3, 4, 5}

union_set_method = set1.union(set2)
print(union_set_method) # Извежда: {1, 2, 3, 4, 5}

	Сечение (Intersection): Връща ново множество, съдържащо само елементите, които се срещат и в двете множества. Може да се извърши с оператора & или метода .intersection().
set1 = {1, 2, 3}
set2 = {3, 4, 5}
intersection_set = set1 & set2
print(intersection_set) # Извежда: {3}

intersection_set_method = set1.intersection(set2)
print(intersection_set_method) # Извежда: {3}

	Разлика (Difference): Връща ново множество, съдържащо елементите от първото множество, които не се срещат във второто множество. Може да се извърши с оператора - или метода .difference().
set1 = {1, 2, 3}
set2 = {3, 4, 5}
difference_set = set1 - set2
print(difference_set)   # Извежда: {1, 2}

difference_set_method = set1.difference(set2)
print(difference_set_method) # Извежда: {1, 2}

	Симетрична разлика (Symmetric Difference): Връща ново множество, съдържащо всички елементи, които се намират в едно от множествата, но не и в двете едновременно. Може да се извърши с оператора ^ или метода .symmetric_difference().

set1 = {1, 2, 3}
set2 = {3, 4, 5}
symmetric_difference_set = set1 ^ set2
print(symmetric_difference_set) # Извежда: {1, 2, 4, 5}
symmetric_difference_set_method = set1.symmetric_difference(set2)
print(symmetric_difference_set_method) # Извежда: {1, 2, 4, 5}

	.issuperset(other_set): Връща True, ако текущото множество е надмножество на other_set (всички елементи на other_set се съдържат в текущото множество). Може да се използва и операторът >=.
set_a = {1, 2}
set_b = {1, 2, 3}
print(set_a.issubset(set_b)) # Извежда: True
print(set_b.issuperset(set_a)) # Извежда: True
print(set_a <= set_b)       # Извежда: True
print(set_b >= set_a)       # Извежда: True
	Разбирането и използването на тези операции прави множествата мощен инструмент за работа с уникални колекции от данни и за извършване на логически операции между тях.

	Функцията zip():
Функцията zip() в Python е вградена функция, която се използва за комбиниране на елементи от няколко итерируеми обекта (като списъци, кортежи и др.) в един итератор от кортежи. Всеки кортеж в итератора съдържа съответните елементи от входните итерируеми обекти.
zip(*iterables)
	*iterables: Един или повече итерируеми обекти (например, списъци, кортежи, множества, низове, речници и др.).
	Как работи zip():
zip() приема няколко итерируеми обекта като аргументи. Тя итерира едновременно през всеки от тези обекти и "сдвоява" елементите, които се намират на една и съща позиция (индекс). Резултатът е итератор, който произвежда кортежи. Всеки кортеж съдържа елементите от съответните итерируеми обекти на тази позиция.
	Важни характеристики:
	Итератор: zip() връща итератор. За да видите резултатите, често се налага да го преобразувате в друга структура от данни, като списък (list()) или речник (dict()).
	Дължина на резултата: Дължината на итератора, върнат от zip(), се определя от най-късия от подадените итерируеми обекти. Когато най-късият итерируем обект бъде изчерпан, zip() спира да произвежда нови кортежи, дори ако другите итерируеми обекти все още имат елементи. 
	Разпакетиране (Unzipping): Можете също така да използвате zip() за "разпакетиране" на итерируем обект от кортежи обратно в отделни кортежи. Това се прави с помощта на оператора * при извикване на zip().

	Примери:
	Комбиниране на два списъка:
names = ["Алиса", "Борис", "Катя"]
age = [25, 30, 28]

combined = zip(names, age)
print(list(combined))  # Изход: [('Алиса', 25), ('Борис', 30), ('Катя', 28)]

2. Комбиниране на три итерируеми обекта:
letters = ['a', 'b', 'c']
numbers = [1, 2, 3]
symbols = ['!', '@', '#']

combined = zip(letters, numbers, symbols)
print(list(combined ))  # Изход: [('a', 1, '!'), ('b', 2, '@'), ('c', 3, '#')]

	Различни дължини на итерируемите обекти:
first = [1, 2, 3, 4]
second = ['a', 'b', 'c']

combined  = zip(first, second)
print(list(combined ))  # Изход: [(1, 'a'), (2, 'b'), (3, 'c')]
Забележете, че елементът 4 от първи е игнориран, защото втори е по-къс.

	Създаване на речник от два списъка:
keys = ["име", "възраст", "град"]
values = ["Иван", 32, "София"]

dictionary = dict(zip(keys, values))
print(dictionary)  # Изход: {'име': 'Иван', 'възраст': 32, 'град': 'София'}

	Разпакетиране (Unzipping):
couples = [('Алиса', 25), ('Борис', 30), ('Катя', 28)]

names, age = zip(*couples)
print(names)    # Изход: ('Алиса', 'Борис', 'Катя')
print(age) # Изход: (25, 30, 28)

Приложение на zip():
zip() е полезна функция в много сценарии, включително:
	Създаване на речници от списъци с ключове и стойности.
	Итериране едновременно през няколко свързани списъка.
	Транспониране на матрици (списък от списъци).
	Обработка на данни, където елементи от различни източници трябва да бъдат комбинирани.

	Обобщение на основните структори:
След като разгледахме подробно списъците, кортежите, речниците и множествата, е полезно да направим кратко обобщение и сравнение на техните ключови характеристики, за да можем по-лесно да избираме най-подходящата структура за конкретна задача:


Характеристика	Списък (List)	Кортеж (Tuple)	Речник (Dictionary)	Множество (Set)
Тип на структурата	Подредена последователност от елементи	Подредена последователност от елементи	Неподредена колекция от двойки ключ-стойност	Неподредена колекция от уникални елементи
Изменяемост	Изменяем (може да се променя)	Неизменяем (не може да се променя след създаване)	Изменяем (може да се променя)	Изменяем (може да се променя)
Дубликати	Позволява дублиращи се елементи	Позволява дублиращи се елементи	Не позволява дублиращи се ключове (стойностите могат да се повтарят)	Не позволява дублиращи се елементи
Индексиране	Достъп до елементи чрез целочислен индекс (започва от 0)	Достъп до елементи чрез целочислен индекс (започва от 0)	Достъп до стойности чрез техните ключове	Не се индексира директно (използва се итерация или преобразуване)
Ред на елементите	Запазва реда на вмъкване	Запазва реда на вмъкване	Не гарантира запазване на реда до Python 3.7, след това редът на вмъкване се запазва	Не гарантира запазване на реда
Приложение	Съхраняване на подредени колекции от елементи, които могат да се променят (добавяне, премахване, редактиране).	Съхраняване на подредени колекции от елементи, които не трябва да се променят (например, константи, записи).	Съхраняване на асоциативни връзки между ключове и стойности, бързо търсене по ключ.	Съхраняване на уникални елементи, бърза проверка за принадлежност, операции с множества (обединение, сечение и др.).
Синтаксис	[елемент1, елемент2, ...]	(елемент1, елемент2, ...)	{ключ1: стойност1, ключ2: стойност2, ...}	{елемент1, елемент2, ...}

Избор на подходяща структура:
	Използвайте списък, когато имате нужда от подредена последователност от елементи, която може да се променя, и където редът и дублиращите се елементи са важни.
	Използвайте кортеж, когато имате нужда от подредена последователност от елементи, която не трябва да се променя след създаване. Кортежите са по-ефективни по отношение на паметта за непроменяеми последователности.
	Използвайте речник, когато имате нужда от бърз достъп до стойности по уникален ключ. Речниците са идеални за представяне на връзки "един към един" или "един към много".
	Използвайте множество, когато искате да съхранявате само уникални елементи и да извършвате операции с множества (проверка за съществуване, обединение, сечение и др.). Редът на елементите в множеството не е гарантиран.

Казус 1: Обработка на резултати от анкета
Представете си, че провеждате анкета, в която хората избират един от няколко възможни отговора. Резултатите са събрани като списък от низове, където всеки низ представлява избран отговор. Напишете програма, която обработва този списък с отговори.

def analyze_survey_results(responses):
    answer_counts = {}
    for response in responses:
        if response in answer_counts:
            answer_counts[response] += 1
        else:
            answer_counts[response] = 1

    print("Резултати от анкетата:")
    for answer, count in answer_counts.items():
        print(f"Отговор: '{answer}', Брой: {count}")

survey_responses = ["да", "не", "да", "може би", "да", "не", "да", "не", "може би", "да"]
analyze_survey_results(survey_responses)

Казус 2: Управление на инвентар
Създайте структура от данни, която да представлява инвентар на магазин. Инвентарът трябва да съдържа информация за всеки артикул: име (низ), количество (цяло число) и цена (число с плаваща запетая). Напишете функции за:
	Добавяне на нов артикул към инвентара.
	Актуализиране на количеството на съществуващ артикул.
	Извеждане на информация за всички артикули в инвентара.
Решение:
inventory = {}

def add_item(name, quantity, price):
    if name in inventory:
        print(f"Артикул '{name}' вече съществува в инвентара.")
    else:
        inventory[name] = {"quantity": quantity, "price": price}
        print(f"Артикул '{name}' беше добавен към инвентара.")

def update_quantity(name, new_quantity):
    if name in inventory:
        inventory[name]["quantity"] = new_quantity
        print(f"Количеството на '{name}' беше актуализирано на {new_quantity}.")
    else:
        print(f"Артикул '{name}' не е намерен в инвентара.")

def display_inventory():
    print("\nИнвентар:")
    for name, details in inventory.items():
        print(f"- Артикул: {name}, Количество: {details['quantity']}, Цена: {details['price']:.2f}")

# Примери за използване
add_item("Ябълки", 100, 1.50)
add_item("Банани", 150, 1.00)
update_quantity("Ябълки", 120)
display_inventory()

Казус 3: Комбиниране и сортиране на данни
Имате два списъка с имена: един със собствени имена и един с фамилии. Напишете програма, която комбинира всяко собствено име с всяка фамилия, за да генерира пълен списък с възможни пълни имена. След това сортирайте този списък по азбучен ред.
Решение:
first_names = ["Иван", "Петър", "Мария"]
last_names = ["Иванов", "Петров", "Георгиева"]
full_names = []

for first in first_names:
    for last in last_names:
        full_names.append((first, last))

full_names.sort()

print("Възможни пълни имена (сортирани):")
for name_tuple in full_names:
    print(f"{name_tuple[0]} {name_tuple[1]}")



Въпроси:
	Кои са основните структури от данни в Python?
	Какво представляват списъците? Какви са основните им характеристики?
	Какво е слайсиране на списък? Дайте примери.
	Какви са основните методи за работа със списъци? Обяснете действието на поне пет от тях.
	Какво представляват кортежите? По какво се различават от списъците? Защо са полезни?
	Какви операции могат да се извършват с кортежи, като се има предвид тяхната неизменяемост?
	Какво представляват речниците в Python? Как се съхраняват данните в тях?
	Как се достъпват, добавят и премахват елементи от речник?
	Избройте и обяснете действието на поне три метода за работа с речници.
	Какво представляват множествата? Какви са техните основни характеристики?
	За какви задачи са полезни множествата?
	Опишете основните операции с множества (добавяне, премахване, обединение, сечение, разлика).
Задачи:
	Създайте списък с числа от 1 до 10. Изведете първите три елемента, последните два и всички елементи с четни индекси.
	Даден е списък numbers = [5, 1, 8, 2, 8, 3]. Премахнете дубликатите и го сортирайте във възходящ ред.
	Създайте кортеж с три имена на града. Опитайте се да промените един от елементите (трябва да получите грешка).
	Създайте речник, съдържащ информация за книга (заглавие, автор, година на издаване). Изведете информацията за автора и годината. Добавете ключ "жанр" със съответна стойност.
	Дадени са два списъка list1 = [1, 2, 3, 4, 5] и list2 = [3, 5, 6, 7]. Преобразувайте ги в множества и намерете тяхното обединение, сечение и разлика (list1 - list2).
 
	Вход и изход от конзолата (input(), print())
 

Взаимодействието с потребителя и показването на резултати са основни аспекти на всяка програма. Python предоставя две основни вградени функции за тези цели, когато работим в конзолна среда: input() за получаване на вход от потребителя и print() за извеждане на информация на конзолата.
	Функция print() - Извеждане на информация	
Функцията print() се използва за показване на текст, стойности на променливи или други обекти на конзолата (стандартния изходен поток). Тя е много гъвкава и приема множество аргументи.
	Извеждане на един аргумент:
Най-простият начин за използване на print() е да ѝ подадете един аргумент, който ще бъде изведен на конзолата, последван от нов ред по подразбиране.
 
	Извеждане на множество аргументи:
Можете да подадете на print() няколко аргумента, разделени със запетаи. По подразбиране, те ще бъдат изведени, разделени с интервал.
name = "Алиса"
age = 30
print("Име:", name, "Възраст:", age) # Извежда: Име: Алиса Възраст: 30

	Аргумент sep (разделител):
Чрез аргумента sep можете да укажете какъв разделител да се използва между изведените аргументи. По подразбиране sep е интервал (' ').
print("едно", "две", "три", sep="-")   # Извежда: едно-две-три
print(1, 2, 3, sep=", ")           # Извежда: 1, 2, 3

	Аргумент end (край):
Чрез аргумента end можете да укажете какво да бъде изведено след последния аргумент. По подразбиране end е символ за нов ред ('\n'). Можете да го промените, за да предотвратите преминаването на нов ред или да изведете нещо друго.

print("Първи ред", end=" ")
print("Втори ред")                 # Извежда: Първи ред Втори ред

for i in range(5):
    print(i, end=", ")           # Извежда: 0, 1, 2, 3, 4,
print()       

	Форматиране на изхода:
Често е необходимо да форматирате изхода, за да го направите по-четим или да включите стойности на променливи по определен начин. Както вече разгледахме в главата за низове, можете да използвате f-strings или метода .format() за тази цел.
F-strings, въведени в Python 3.6, предоставят елегантен и четим начин за вграждане на изрази вътре в низови литерали. За да създадете f-string, просто поставете f или F преди началната кавичка на низа. Вътре в низа можете да поставяте изрази в къдрави скоби {}. Тези изрази ще бъдат оценени по време на изпълнение и резултатът им ще бъде вмъкнат в низа.
	Вграждане на променливи:
	Най-простият случай е директното вграждане на променливи:
name = "Борис"
age = 28
print(f"Здравей, {name}! Ти си на {age} години.")

	Вграждане на изрази:
	Можете да вграждате по-сложни изрази, включително аритметични операции, извиквания на функции и др.:
x = 10
y = 5
print(f"Сумата на {x} и {y} е {x + y}.")
print(f"Квадратният корен на 2 е {2**0.5:.3f}.") # Форматиране на десетични знаци

	Спецификатори за формат:
	Вътре в къдравите скоби след двоеточие : можете да указвате спецификатори за формат, които контролират как ще бъде представен резултатът от израза. Някои често използвани спецификатори включват:
:d:	Цяло число (десятично).
:f:	Число с плаваща запетая (десятично). Можете да укажете броя на знаците след десетичната запетая, например :.2f за два знака.
:b:	Двоично представяне на цяло число.
:o:	Осмично представяне на цяло число.
:x:	Шестнадесетично представяне на цяло число (с малки букви). Използвайте :X за големи букви.
:e:	Научно (експоненциално) представяне.
:s:	 Низ (по подразбиране). 

:>w:	Подравняване вдясно в поле с ширина w.
:<w:	Подравняване вляво в поле с ширина w.
:^w:	Центриране в поле с ширина w.
:,:	Добавяне на разделители за хиляди (за числа).
:%:	Представяне като процент (умножава по 100 и добавя %). Може да се комбинира с броя на десетичните знаци (например :.2%).


number = 123
float_num = 12.3456
text = "Python"

print(f"Цяло число: {number:d}")
print(f"Десетично число с два знака: {float_num:.2f}")
print(f"Десетично число в научно представяне: {float_num:.2e}")
print(f"Двоично: {number:b}")
print(f"Шестнадесетично (малки букви): {number:x}")
print(f"Низ, подравнен вдясно в поле от 10 знака: {text:>10}")
print(f"Голямо число с разделители: {1234567:,}")
percentage = 0.85
print(f"Процент: {percentage:.1%}")


	Функция input() - Получаване на вход от потребителя
Функцията input() се използва за получаване на текст (низ) от потребителя, който въвежда информация в конзолата и натиска Enter.

	Основно използване:
city = input("В кой град живеете? ")
print(f"Вие живеете в {city}.")
Когато се извика input(), програмата спира изпълнението си и чака потребителя да въведе текст и да натисне Enter. Въведеният текст (включително интервалите) се връща като низ.

	Входът винаги е низ:
Функцията input() винаги връща стойността, въведена от потребителя, като низ (тип str). Ако очаквате потребителят да въведе число, ще трябва да преобразувате върнатия низ към съответния числов тип (например int() или float()).

age_str = input("Моля, въведете вашата възраст: ")
try:
    age = int(age_str)
    print(f"След 5 години ще бъдете на {age + 5} години.")
except ValueError:
    print("Невалидна възраст. Моля, въведете цяло число.")
price_str = input("Моля, въведете цена: ")
try:
    price = float(price_str)
    print(f"Цената с ДДС е: {price * 1.20:.2f} лв.")
except ValueError:
    print("Невалидна цена. Моля, въведете число.")

	Подаване на подкана (prompt):
Можете да подадете низ като аргумент на функцията input(). Този низ ще бъде изведен на конзолата като подкана към потребителя, преди да се очаква въвеждане.
name = input("Моля, въведете вашето име: ")
print(f"Здравейте, {name}!")

age_str = input("Моля, въведете вашата възраст: ")
print(f"Вашата възраст е: {age_str}.")
	Функциите print() и input() са основните средства за взаимодействие с потребителя в конзолни приложения на Python. Разбирането на техните възможности и правилното им използване е важно за създаването на интерактивни програми.

Казус 1: Калкулатор за прости аритметични операции
Напишете програма, която пита потребителя да въведе две числа и операция (+, -, *, /). Програмата трябва да извърши избраната операция и да изведе резултата. Ако потребителят въведе невалидна операция, трябва да се покаже съобщение за грешка.
Решение:
num1_str = input("Въведете първото число: ")
num2_str = input("Въведете второто число: ")
operation = input("Въведете операция (+, -, *, /): ")

try:
    num1 = float(num1_str)
    num2 = float(num2_str)

    if operation == '+':
        result = num1 + num2
    elif operation == '-':
        result = num1 - num2
    elif operation == '*':
        result = num1 * num2
    elif operation == '/':
        if num2 == 0:
            print("Грешка: Деление на нула!")
        else:
            result = num1 / num2
    else:
        print("Грешка: Невалидна операция!")
        result = None

    if result is not None:
        print(f"Резултатът е: {result}")

except ValueError:
    print("Грешка: Моля, въведете валидни числа.")

result_division = num1 / num2
print("{num1} / {num2} = {result_division} ")

Казус 2: Създаване на персонализирано съобщение
Напишете програма, която пита потребителя за неговото име и любим цвят. След това програмата трябва да изведе персонализирано съобщение, което включва въведените данни.
Решение:
name = input("Как се казвате? ")
favorite_color = input("Какъв е любимият ви цвят? ")

message = f"Здравей, {name}! Любимият ти цвят е {favorite_color}."
print(message)

Казус 3: Проверка на парола
Напишете програма, която първо задава предварително дефинирана парола (например "secret"). След това пита потребителя да въведе парола. Програмата трябва да сравни въведената парола с предварително дефинираната и да изведе съобщение дали паролите съвпадат или не.
Решение:
correct_password = "secret"
entered_password = input("Моля, въведете парола: ")

if entered_password == correct_password:
    print("Успешно! Паролите съвпадат.")
else:
    print("Грешка: Грешна парола.")
	Тези казуси се фокусират върху получаване на вход от потребителя с input() и извеждане на резултати и съобщения с print(). Те включват и основни условни проверки, които вероятно ще бъдат разгледани в следващите глави, но са интуитивни за разбиране в контекста на тези задачи.

 
Въпроси:
	За какво се използва функцията print() в Python? Дайте примери за извеждане на един и на няколко аргумента.
	Обяснете ролята на аргумента sep във функцията print(). Каква е стойността му по подразбиране? Дайте пример за неговото използване.
	Обяснете ролята на аргумента end във функцията print(). Каква е стойността му по подразбиране? Как можем да предотвратим преминаването на нов ред при извеждане?
	Как можем да форматираме изхода с помощта на функцията print()? Споменете поне два начина.
	За какво се използва функцията input() в Python? Какъв тип данни връща тази функция?
	Защо е важно да преобразуваме типа данни, върнат от input(), ако очакваме число или друг тип, различен от низ? Дайте пример.
	Как можем да покажем подкана (prompt) към потребителя, когато използваме функцията input()?
Задачи:
	Напишете програма, която пита потребителя за неговото име и любим цвят. След това изведете съобщение, което включва тези две парчета информация, използвайки f-string.
	Напишете програма, която извежда числата от 1 до 5 на един ред, разделени със запетая и последвани от удивителен знак.
	Напишете програма, която пита потребителя за две числа. Преобразувайте ги към float и изведете техния среден аритметичен.
	Напишете програма, която пита потребителя дали обича програмиране (въведете "да" или "не"). Изведете съобщение, съответстващо на неговия отговор.
	Напишете програма, която приема три думи от потребителя и ги извежда на един ред, разделени с тире.
	Напишете програма, която пита потребителя за радиус на кръг. Пресметнете неговия периметър (2πr) и лице (πr²) и ги изведете форматирано до два знака след десетичната запетая. (Можете да използвате π≈3.14159).
 
	Управляващи структури
 
 
Управляващите структури в езиците за програмиране позволяват да контролирате потока на изпълнение на програмата въз основа на определени условия или да повтаряте определени блокове от код многократно. Python предоставя два основни вида управляващи структури: условни конструкции и цикли.
	Условни конструкции (if, elif, else)
Условните конструкции позволяват на програмата да взема решения и да изпълнява различни блокове от код в зависимост от това дали дадено условие е истина (True) или лъжа (False). Python използва ключовите думи if, elif (съкращение от "else if") и else за създаване на условни конструкции.

	if конструкция:
Блокът код, следващ if се изпълнява само ако условието след if е True.
age = 20
if age >= 18:
    print("Вие сте пълнолетен.")

	else конструкция:
Блокът код, следващ else, се изпълнява само ако условието в предходния if (или elif) е False. else е опционална и може да има само една в една условна конструкция.
age = 15
if age >= 18:
    print("Вие сте пълнолетен.")
else:
    print("Вие сте непълнолетен.")

	elif конструкция:
elif позволява да проверявате множество условия последователно. Блокът код след първото elif, чието условие е True, се изпълнява. Може да има нула или повече elif конструкции между if и else. else е също опционална и се изпълнява, ако нито едно от условията в if или elif не е True.

score = 75
if score >= 90:
    grade = "A"
elif score >= 80:
    grade = "B"
elif score >= 70:
    grade = "C"
elif score >= 60:
    grade = "D"
else:
    grade = "F"
print(f"Вашата 1  оценка е: {grade}")
	Важно е да се отбележи, че след като едно от условията (if или някое от elif) бъде изпълнено, останалите условия не се проверяват и програмата продължава изпълнението си след края на условната конструкция.

	Вложени if конструкции:
Възможно е да поставяте if конструкции вътре в други if, elif или else блокове. Това се нарича вложени условни конструкции и позволява да се проверяват по-сложни сценарии.
has_license = True
has_car = True
age = 17

if has_license:
    if has_car:
        if age >= 18:
            print("Можете да шофирате.")
        else:
            print("Имате кола и книжка, но сте твърде млад.")
    else:
        print("Имате книжка, но нямате кола.")
else:
    print("Нямате шофьорска книжка.")
	Условните конструкции са фундаментален инструмент за създаване на програми, които могат да се адаптират към различни ситуации и да вземат решения въз основа на данните, с които работят.

	Цикли (for, while)
Циклите позволяват многократното изпълнение на определен блок от код. Python предлага два основни вида цикли: for цикъл, който се използва за итериране върху последователности (като списъци, кортежи, низове) или други итерируеми обекти, и while цикъл, който се изпълнява, докато дадено условие е истина.
	for цикъл:
for цикълът се използва за обхождане на елементите на дадена последователност (например списък, кортеж, низ) или друг итерируем обект.
fruits = ["ябълка", "банан", "череша"]
for fruit in fruits:
    print(fruit)
# Извежда:
# ябълка
# банан
# череша

numbers = [1, 2, 3, 4, 5]
for num in numbers:
    squared = num ** 2
    print(f"Квадратът на {num} е {squared}.")

text = "Python"
for char in text:
    print(char)
# Извежда:
# P
# y
# t
# h
# o
# n

	Функция range():
Функцията range() често се използва с for цикъл за генериране на последователност от числа. Тя може да приема един, два или три аргумента:
	range(stop): Генерира последователност от 0 до stop (не включително).
	range(start, stop): Генерира последователност от start до stop (не включително).
	range(start, stop, step): Генерира последователност от start до stop (не включително) със стъпка step.
for i in range(5):
    print(i)      # Извежда: 0, 1, 2, 3, 4

for i in range(2, 7):
    print(i)      # Извежда: 2, 3, 4, 5, 6

for i in range(0, 10, 2):
    print(i)      # Извежда: 0, 2, 4, 6, 8

for i in range(5, 0, -1):
    print(i)      # Извежда: 5, 4, 3, 2, 1

	while цикъл:
while цикълът изпълнява блок от код, докато дадено условие е True. Важно е да се уверите, че условието в крайна сметка ще стане False, за да избегнете безкраен цикъл.
count = 0
while count < 5:
    print(f"Броячът е: {count}")
    count += 1
# Извежда:
# Броячът е: 0
# Броячът е: 1
# Броячът е: 2
# Броячът е: 3
# Броячът е: 4

number = 10
while number > 0:
    print(number)
    number -= 2
# Извежда:
# 10
# 8
# 6
# 4
# 2

	break оператор:
Операторът break се използва за незабавно излизане от текущия цикъл (for или while). Програмата продължава изпълнението си със следващия ред код след цикъла.
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num == 3:
        break
    print(num)
# Извежда:
# 1
# 2

count = 0
while True:
    print(count)
    count += 1
    if count > 5:
        break
# Извежда: 0, 1, 2, 3, 4, 5


	continue оператор:
Операторът continue се използва за прекъсване на текущата итерация на цикъла и преминаване към следващата итерация. Кодът след continue в текущата итерация се пропуска.
numbers = [1, 2, 3, 4, 5]
for num in numbers:
    if num == 3:
        continue
    print(num)
# Извежда:
# 1
# 2
# 4
# 5

count = 0
while count < 5:
    count += 1
    if count == 3:
        continue
    print(f"Броячът е: {count}")
# Извежда:
# Броячът е: 1
# Броячът е: 2
# Броячът е: 4
# Броячът е: 5

	Вложени цикли:
Подобно на условните конструкции, е възможно да поставяте цикли вътре в други цикли. Това се нарича вложени цикли и е полезно за обхождане на многомерни структури от данни или за изпълнение на повтарящи се действия в рамките на друга повтаряща се структура.
for i in range(3):
    for j in range(2):
        print(f"Външен цикъл: {i}, Вътрешен цикъл: {j}")
# Извежда:
# Външен цикъл: 0, Вътрешен цикъл: 0
# Външен цикъл: 0, Вътрешен цикъл: 1
# Външен цикъл: 1, Вътрешен цикъл: 0
# Външен цикъл: 1, Вътрешен цикъл: 1
# Външен цикъл: 2, Вътрешен цикъл: 0
# Външен цикъл: 2, Вътрешен цикъл: 1

rows = 5
cols = 5
for i in range(rows):
    for j in range(cols):
        print("*", end=" ")
    print() # Нов ред след всеки ред звездички
# Извежда квадрат от звездички
	Циклите са основен инструмент за автоматизиране на повтарящи се задачи и за обработка на колекции от данни в програмирането. Разбирането на различните видове цикли и контролните оператори (break и continue) е от съществено значение.

Казус 1: Класифициране на триъгълници
Напишете програма, която приема дължините на три страни на триъгълник като вход от потребителя. Програмата трябва да определи и изведе вида на триъгълника: равностранен (всички страни са равни), равнобедрен (две страни са равни) или разностранен (всички страни са различни). Програмата трябва също да провери дали въведените дължини могат да образуват триъгълник (сумата на всеки две страни трябва да е по-голяма от третата).
Решение:
def classify_triangle():
    try:
        side1 = float(input("Въведете дължината на първата страна: "))
        side2 = float(input("Въведете дължината на втората страна: "))
        side3 = float(input("Въведете дължината на третата страна: "))

        if side1 + side2 > side3 and side1 + side3 > side2 and side2 + side3 > side1:
            if side1 == side2 == side3:
                print("Триъгълникът е равностранен.")
            elif side1 == side2 or side1 == side3 or side2 == side3:
                print("Триъгълникът е равнобедрен.")
            else:
                print("Триъгълникът е разностранен.")
        else:
            print("Въведените дължини не могат да образуват триъгълник.")

    except ValueError:
        print("Грешка: Моля, въведете валидни числа за дължини на страните.")

classify_triangle()

Казус 2: Игра "Познай числото"
Напишете програма, която генерира случайно цяло число между 1 и 100. След това програмата подканва потребителя да познае числото. При всеки опит програмата трябва да казва дали познатото число е по-голямо, по-малко или равно на генерираното число. Играта продължава, докато потребителят не познае числото. Програмата трябва също да брои броя на опитите.
Решение:
import random 

def guess_the_number():
    secret_number = random.randint(1, 100)
    attempts = 0
    guessed = False

    print("Познайте числото между 1 и 100.")

    while not guessed:
        try:
            guess_str = input("Вашият опит: ")
            guess = int(guess_str)
            attempts += 1

            if guess < secret_number:
                print("Търсеното число е по-голямо.")
            elif guess > secret_number:
                print("Търсеното число е по-малко.")
            else:
                print(f"Поздравления! Познахте числото {secret_number} от {attempts} опита.")
                guessed = True

        except ValueError:
            print("Грешка: Моля, въведете цяло число.")
guess_the_number()

Казус 3: Извеждане на проста таблица
Напишете програма, която използва вложени цикли, за да изведе таблица за умножение за числата от 1 до 5. Таблицата трябва да бъде форматирана по начин, който е лесен за четене.
Решение:
def print_multiplication_table():
    print("Таблица за умножение (1 до 5):\n")
    print("  |", end="")
    for i in range(1, 6):
        print(f"{i:4}", end="")  # Форматиране за подравняване
    print("\n--+--------------------")

    for i in range(1, 6):
        print(f"{i} |", end="")
        for j in range(1, 6):
            print(f"{i * j:4}", end="")  # Форматиране за подравняване
        print()

print_multiplication_table()

	Тези казуси демонстрират използването на if, elif, else за вземане на решения, for и while цикли за повтарящи се действия, както и break (въпреки че не е изрично използван тук, може да бъде добавен към играта "Познай числото" за ограничаване на броя опити) и range() за генериране на последователности. Вложеният цикъл е използван за създаване на таблицата за умножение.
 
Въпроси:
	Обяснете как работи условната конструкция if. Кога се изпълнява блокът код след if?
	Каква е ролята на else в една условна конструкция? Може ли да има повече от един else блок?
	Какво представлява elif и кога се използва? Може ли да има няколко elif блока?
	Какво е вложена условна конструкция? Дайте пример.
	Какво представлява итерация?
	Обяснете как работи for цикълът в Python. За какво най-често се използва?
	Какво прави операторът break в цикъл? Дайте пример.
	Какво прави операторът continue в цикъл? Дайте пример.
	В какви ситуации е полезно да използваме break и continue?
	Как се използва функцията range() с for цикъл? Дайте примери с един, два и три аргумента.
	Обяснете как работи while цикълът. Кога се прекратява неговото изпълнение? Каква опасност крие използването на while цикъл?
	Каква е разликата между for и while цикъл? В какви ситуации е по-подходящ единият от другия?
	Какво представляват вложените цикли? Дайте пример за тяхното използване.
	Колко пъти ще се изпълни вътрешният цикъл в една вложена структура?

Задачи:
	Напишете програма, която извежда всички четни числа от 2 до 20 включително, използвайки for цикъл и range().
	Напишете програма, която изчислява сумата на всички числа от 1 до 100, използвайки while цикъл.
	Напишете програма, която приема число като вход и извежда неговата таблица за умножение до 10.
	Напишете програма, която обхожда списък с имена и извежда всяко име с неговия пореден номер.
	Напишете код, който проверява дали дадено число е положително, отрицателно или нула.
	Напишете програма, която пита потребителя за неговата възраст. Ако е под 13 години, изведете "Вие сте дете."; ако е между 13 и 19 включително, изведете "Вие сте тийнейджър."; ако е над 19, изведете "Вие сте възрастен.".
	Напишете програма, която приема три числа като вход и извежда най-голямото от тях.
	Напишете програма, която проверява дали дадена година е високосна. (Високосна е годината, която се дели на 4, но не се дели на 100, освен ако се дели и на 400).
	Напишете програма, която пита потребителя за оценка (A, B, C, D, F). Изведете съответното описание ("Отличен", "Много добър", "Добър", "Среден", "Слаб"). Ако е въведена невалидна оценка, изведете съобщение за грешка.
	Напишете програма, която чете числа от потребителя, докато не бъде въведено числото 0. След това изведете сумата на всички въведени числа (без 0). Използвайте while цикъл и break.
	Напишете програма, която обхожда списък с числа. Ако числото е отрицателно, го пропуска и продължава със следващото. Изведете само положителните числа. Използвайте for цикъл и continue.
	Напишете програма, която извежда следния модел от звездички: 

*
* *
* * *
* * * *
* * * * *

*Използвайте вложени for цикли.
	Напишете програма, която намира всички прости числа в диапазона от 2 до 50, използвайки вложени цикли. (Едно число е просто, ако се дели само на 1 и на себе си).
*Потърсете информация и опитайте да имплементирате различни алгоритми.

 
	Функции в Python
  
Функциите са основни градивни елементи на всеки структуриран език за програмиране, включително Python. Те позволяват да групирате блок от код, който изпълнява определена задача, и да го извиквате многократно от различни части на програмата, без да се налага да пишете същия код отново и отново. Функциите спомагат за организирането на кода, правят го по-четим, по-лесен за поддръжка и за многократно използване.
	Дефиниране на функции (def)
За да дефинирате функция в Python, използвате ключовата дума def, последвана от името на функцията, списък от параметри в кръгли скоби (), и накрая двоеточие :. Блокът код, който представлява тялото на функцията, трябва да бъде отместен навътре.
def greet(name):
    """Тази функция поздравява човека, подаден като параметър."""
    print(f"Здравей, {name}!")

# Извикване на функцията
greet("Алиса")  # Извежда: Здравей, Алиса!
greet("Борис")  # Извежда: Здравей, Борис!

	Име на функция: Трябва да следва стандартните правила за именуване на променливи в Python (букви, цифри, долна черта, не може да започва с цифра). Добре е имената на функциите да описват какво прави функцията. 
	Параметри (аргументи): Това са променливи, които получават стойности, когато функцията бъде извикана. Списъкът от параметри може да бъде празен. 
	Документационен низ (docstring): Първият ред след дефинирането на функцията често е многоредов низ, заграден с тройни кавички ("""Docstring goes here"""). Той служи като документация за функцията, описвайки какво прави, какви параметри приема и каква стойност връща (ако има такава). 
	Тяло на функцията: Блокът код, който се изпълнява, когато функцията бъде извикана.
	Аргументи
Когато извиквате функция, вие ѝ подавате стойности, наречени аргументи, които се присвояват на параметрите, дефинирани във функцията. Python поддържа няколко вида аргументи:
	Позиционни аргументи: 
Това са аргументи, които се подават на функцията в реда, в който са дефинирани съответните параметри.
def describe_pet(animal_type, pet_name):
    """Показва информация за домашен любимец."""
    print(f"\nИмам {animal_type} на име {pet_name}.")

describe_pet("хамстер", "Жорко")  # "хамстер" се присвоява на animal_type, "Жорко" на pet_name
describe_pet("куче", "Бък")     # "куче" се присвоява на animal_type, "Бък" на pet_name

	Ключови аргументи:
 Когато извиквате функция, можете да подавате аргументи, като указвате името на параметъра, на който искате да присвоите стойност, използвайки синтаксиса параметър=стойност. Редът на ключовите аргументи няма значение.
describe_pet(pet_name="Луси", animal_type="котка")
describe_pet(animal_type="заек", pet_name="Бъни")

	Аргументи по подразбиране: 
Когато дефинирате функция, можете да зададете стойности по подразбиране за някои параметри. Ако при извикване на функцията не бъде подадена стойност за такъв параметър, ще се използва стойността по подразбиране. Параметрите със стойности по подразбиране трябва да бъдат дефинирани след параметрите без стойности по подразбиране.
def power(base, exponent=2):
    """Връща base на степен exponent (по подразбиране 2)."""
    return base ** exponent

print(power(5))       # Използва се стойността по подразбиране за exponent (2), извежда 25
print(power(5, 3))    # Подава се стойност за exponent (3), извежда 125

	*args (произволен брой позиционни аргументи): 
Понякога не знаете предварително колко позиционни аргумента ще бъдат подадени на функцията. В този случай можете да използвате *args като последен параметър в дефиницията на функцията. Python ще събере всички допълнителни позиционни аргументи в кортеж с име args.
def sum_all(*args):
    """Връща сумата на всички подадени числа."""
    total = 0
    for num in args:
        total += num
    return total

print(sum_all(1, 2, 3))       # Извежда: 6
print(sum_all(10, 20, 30, 40)) # Извежда: 100
print(sum_all())             # Извежда: 0 (празен кортеж)

	**kwargs (произволен брой ключови аргументи): 
Подобно на *args, **kwargs позволява на функцията да приема произволен брой ключови аргументи. Python ще събере тези аргументи в речник с име kwargs, където ключовете са имената на аргументите, а стойностите са техните стойности.
def build_profile(first, last, **kwargs):
    """Създава речник, съдържащ информация за потребител."""
    profile = {}
    profile['first_name'] = first
    profile['last_name'] = last
    for key, value in kwargs.items():
        profile[key] = value
    return profile

user_profile = build_profile("алберт", "айнщайн", location="принстън", field="физика")
print(user_profile)
# Извежда: {'first_name': 'алберт', 'last_name': 'айнщайн', 'location': 'принстън', 'field': 'физика'}
При дефиниране на функция, редът на параметрите обикновено е:
	Позиционни параметри
	Параметри със стойности по подразбиране
	*args
	**kwargs
	Връщане на стойности (return)
Функцията може да върне стойност (или стойности) на мястото, където е била извикана, използвайки оператора return. Когато се срещне оператор return, функцията спира изпълнението си и връща указаната стойност. Ако функция не съдържа return оператор или съдържа return без стойност, тя връща специалната стойност None.
def add(x, y):
    """Връща сумата на x и y."""
    return x + y

result = add(5, 3)
print(result)  # Извежда: 8

def format_name(first_name, last_name):
    """Връща пълното име, форматирано."""
    full_name = f"{first_name} {last_name}"
    return full_name.title()

formatted_name = format_name("john", "doe")
print(formatted_name) # Извежда: John Doe

def get_full_info(name, age=None):
    """Връща името и възрастта (ако е предоставена)."""
    info = {"name": name}
    if age is not None:
        info["age"] = age
    return info

person1 = get_full_info("Мария", 25)
person2 = get_full_info("Петър")
print(person1) # Извежда: {'name': 'Мария', 'age': 25}
print(person2) # Извежда: {'name': 'Петър'}
	Функциите, които връщат стойности, са много полезни, тъй като позволяват да се обработват резултатите от функцията в други части на програмата.

	Обхват на променливите (локални, глобални)
Обхватът на една променлива определя къде в програмата тази променлива може да бъде достъпена (видима). В Python има основно два вида обхват: локален и глобален.
	Локални променливи:
Променливите, дефинирани вътре във функция, имат локален обхват. Това означава, че те са достъпни само в рамките на тази функция и не могат да бъдат директно достъпени от код извън функцията. Когато функцията завърши изпълнението си, локалните променливи се унищожават.
def my_function():
    local_var = 10
    print(f"Вътре във функцията: local_var = {local_var}")

my_function()  # Извежда: Вътре във функцията: local_var = 10

print(local_var) # Ще генерира NameError: name 'local_var' is not defined

	Глобални променливи:
Променливите, дефинирани извън всички функции (на най-високо ниво на модула), имат глобален обхват. Те могат да бъдат достъпни от всяка част на програмата, включително вътре във функции.
global_var = 20

def another_function():
    print(f"Вътре във функцията: global_var = {global_var}")

another_function()  # Извежда: Вътре във функцията: global_var = 20
print(f"Извън функцията: global_var = {global_var}") # Извежда: Извън функцията: global_var = 20

	Изменение на глобални променливи вътре във функция:
Ако искате да промените стойността на глобална променлива вътре във функция, трябва изрично да декларирате, че използвате глобалната променлива, като използвате ключовата дума global. Без global, ако присвоите стойност на променлива със същото име вътре във функция, Python ще създаде нова локална променлива със същото име, която "засенчва" глобалната променлива в рамките на тази функция.
counter = 0

def increment_counter():
    global counter
    counter += 1
    print(f"Броячът вътре във функцията: {counter}")

increment_counter()  # Извежда: Броячът вътре във функцията: 1
print(f"Броячът извън функцията: {counter}") # Извежда: Броячът извън функцията: 1

def another_increment():
    counter = 100  # Създава нова локална променлива 'counter'
    print(f"Локален брояч във втората функция: {counter}")

another_increment() # Извежда: Локален брояч във втората функция: 100
print(f"Броячът извън функцията (след втората функция): {counter}") # Извежда: Броячът извън функцията (след втората функция): 1

	Правило LEGB (Local, Enclosing function locals, Global, Built-in):
Когато Python търси стойността на дадена променлива, той следва определен ред, известен като правило LEGB:
	Local: Първо търси в локалния обхват (вътре във функцията).
	Enclosing function locals: Ако променливата не е намерена в локалния обхват, Python търси в обхвата на обвиващите (външни) функции (ако има такива - при вложени функции).
	Global: Ако не е намерена в обвиващите обхвати, търси в глобалния обхват (на ниво модул).
	Built-in: Накрая, ако все още не е намерена, търси във вградения обхват на Python (съдържащ вградени функции и константи като print(), len(), True, False и др.).
	Разбирането на обхвата на променливите е важно, за да се избегнат нежелани странични ефекти и да се пише по-ясен и по-организиран код. Препоръчително е да се използват локални променливи възможно най-много и да се избягва прекомерното използване на глобални променливи, тъй като това може да направи кода по-труден за разбиране и поддръжка.


	Анонимни функции (lambda)
В Python, освен стандартния начин за дефиниране на функции с помощта на ключовата дума def, съществува и начин за създаване на малки, едноредови функции, които нямат име. Тези функции са известни като анонимни функции или lambda функции.
Синтаксисът за дефиниране на lambda функция е следният:
lambda arguments: expression
	lambda: Ключовата дума, която указва, че се дефинира анонимна функция. 
	arguments: Списък от един или повече аргументи, разделени със запетаи. Те са подобни на параметрите в обикновена функция, но не са оградени в скоби. 
	:expression: Единичен израз, който се оценява и чийто резултат се връща от функцията. Изразът не може да съдържа оператори за присвояване или други сложни конструкции като if, for или while.
Lambda функциите често се използват на места, където е необходима малка функция за кратко време, например като аргумент на функция от по-висок ред (функция, която приема други функции като аргументи).
Ето няколко примера:

# Lambda функция, която приема един аргумент и връща неговия квадрат
square = lambda x: x**2
print(square(5))  # Извежда: 25

# Lambda функция, която приема два аргумента и връща тяхната сума
add = lambda x, y: x + y
print(add(3, 7))   # Извежда: 10

# Lambda функция, която приема низ и го преобразува в главни букви
uppercase = lambda s: s.upper()
print(uppercase("hello")) # Извежда: HELLO
Lambda функциите могат да приемат произволен брой аргументи, включително позиционни, ключови и *args, **kwargs.
# Lambda функция с позиционни аргументи
multiply = lambda a, b, c: a * b * c
print(multiply(2, 3, 4)) # Извежда: 24

# Lambda функция с ключов аргумент по подразбиране
power = lambda base, exponent=2: base ** exponent
print(power(3))    # Извежда: 9
print(power(3, 4)) # Извежда: 81

# Lambda функция с *args
sum_all = lambda *args: sum(args)
print(sum_all(1, 2, 3, 4)) # Извежда: 10

# Lambda функция с **kwargs (връща речник)
create_dict = lambda **kwargs: kwargs
my_dict = create_dict(name="Alice", age=30)
print(my_dict) # Извежда: {'name': 'Alice', 'age': 30}
Едно от най-честите приложения на lambda функциите е при използване на вградени функции като map(), filter() и sorted(), които приемат функция като аргумент.
numbers = [1, 2, 3, 4, 5]
# Използване на lambda с map() за повдигане на квадрат на всеки елемент
squared_numbers = list(map (lambda x: x**2, numbers))
print(squared_numbers) # Извежда: [1, 4, 9, 16, 25]

# Използване на lambda с filter() за филтриране на четни числа
even_numbers = list(filter  (lambda x: x % 2 == 0, numbers))
print(even_numbers)  # Извежда: [2, 4]

# Използване на lambda със sorted() за сортиране на списък от речници по стойността на ключа 'age'
people = [{'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 30}, {'name': 'Charlie', 'age': 20}]
sorted_people = sorted(people, key=lambda person: person['age'])
print(sorted_people)
# Извежда: [{'name': 'Charlie', 'age': 20}, {'name': 'Bob', 'age': 25}, {'name': 'Alice', 'age': 30}]
Въпреки че lambda функциите са удобни за кратки операции, за по-сложни функции е препоръчително да се използва стандартната def дефиниция, тъй като тя е по-четима и позволява включването на множество изрази и оператори.

	Декоратори (Decorators)
Декораторите са мощна и елегантна възможност в Python, която позволява да се модифицира или разшири функционалността на функции и методи по четим и многократно използваем начин. Декораторът е функция, която приема друга функция като аргумент, "обвива" я с някаква допълнителна функционалност и връща модифицираната функция.
Синтаксисът за използване на декоратор е чрез символа @ (синтаксатична захар), поставен непосредствено преди дефиницията на функцията, която искате да декорирате.
def my_decorator(func):
    def wrapper():
        print("Something is happening before the function is called.")
        func()
        print("Something is happening after the function is called.")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
В този пример my_decorator е декоратор, а @my_decorator над say_hello означава, че функцията say_hello е декорирана с my_decorator. Когато извикаме say_hello(), всъщност се изпълнява функцията wrapper, дефинирана вътре в my_decorator.
	Как работят декораторите?
Когато използвате @my_decorator над say_hello, Python интерпретира това като:
say_hello = my_decorator(say_hello)
Декораторът my_decorator приема функцията say_hello като аргумент и връща нова функция (wrapper), която замества оригиналната say_hello.
	Примери за употреба на декоратори:
Декораторите имат много приложения, включително:
	Логиране (Logging): Записване на информация за извикванията на функции.
	Проверка на права за достъп (Access Control): Ограничаване на достъпа до определени функции въз основа на потребителски права.
	Измерване на времето за изпълнение (Timing): Анализиране на производителността на функциите.
	Кеширане (Caching): Запазване на резултатите от скъпи функции за бъдещи извиквания със същите аргументи.
	Валидиране на входни данни (Input Validation): Проверка на аргументите, подадени на функцията.
	Декоратори с аргументи:
Декораторите могат да приемат и аргументи. За целта се създава обвиваща функция около самия декоратор.
def repeat(num_times):
    def decorator_repeat(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                func(*args, **kwargs)
        return wrapper
    return decorator_repeat

@repeat(num_times=3)
def greet(name):
    print(f"Hello, {name}!")

greet("Alice")
В този пример repeat е декоратор, който приема аргумент num_times. Той връща друг декоратор decorator_repeat, който обвива функцията greet и я изпълнява num_times пъти.
Декораторите са важен инструмент в Python за писане на по-чист, по-организиран и по-модулен код. Разбирането им е ключово за напредъка ви в Python програмирането.

Казус 1: Калкулатор с функции
Преобразувайте казуса за прост аритметичен калкулатор от предишната глава във функция, която приема две числа и операция като аргументи и връща резултата от операцията. Напишете и основна част на програмата, която взема вход от потребителя и използва тази функция, за да извърши изчислението и да изведе резултата.
Решение:
def calculate(num1, num2, operation):
    if operation == '+':
        return num1 + num2
    elif operation == '-':
        return num1 - num2
    elif operation == '*':
        return num1 * num2
    elif operation == '/':
        if num2 == 0:
            return "Грешка: Деление на нула!"
        else:
            return num1 / num2
    else:
        return "Грешка: Невалидна операция!"

num1_str = input("Въведете първото число: ")
num2_str = input("Въведете второто число: ")
operation = input("Въведете операция (+, -, *, /): ")

try:
    num1 = float(num1_str)
    num2 = float(num2_str)
    result = calculate(num1, num2, operation)
    print(f"Резултатът е: {result}")
except ValueError:
    print("Грешка: Моля, въведете валидни числа.")

Казус 2: Форматиране на потребителско име
Напишете функция, която приема собствено име и фамилия като позиционни аргументи и незадължителен аргумент title (по подразбиране None). Функцията трябва да върне форматирано потребителско име във формат "Фамилия, Собствено Име" (ако title е None) или "[Title] Фамилия, Собствено Име" (ако title е зададен). Използвайте ключови аргументи при извикване на функцията в някои случаи.
Решение:
def format_username(first_name, last_name, title=None):
    if title:
        return f"{title} {last_name}, {first_name}"
    else:
        return f"{last_name}, {first_name}"

print(format_username("Иван", "Иванов"))
print(format_username("Мария", "Петрова", title="Г-жа"))
print(format_username(first_name="Петър", last_name="Георгиев"))

Казус 3: Събиране на произволен брой числа
Напишете функция, която приема произволен брой числови аргументи и връща тяхната сума. Използвайте *args за тази цел.
Решение:
def sum_all(*args):
    total = 0
    for num in args:
        total += num
    return total

print(sum_all(1, 2, 3))
print(sum_all(10, 20, 30, 40, 50))
print(sum_all())
Казус 4: Обработка на информация за продукт
Напишете функция, която приема произволен брой ключови аргументи, представляващи информация за продукт (например име, цена, категория и т.н.). Функцията трябва да изведе тази информация във формат "Ключ: Стойност" за всеки подаден аргумент. Използвайте **kwargs за тази цел.
Решение:
def display_product_info(**kwargs):
    print("Информация за продукта:")
    for key, value in kwargs.items():
        print(f"{key}: {value}")

display_product_info(name="Лаптоп", price=1200.50, category="Електроника", brand="Lenovo")
display_product_info(title="Книга", author="Иван Вазов", year=1894)

Казус 5: Удвояване на четни числа с lambda функция
Напишете функция, която приема списък с числа като аргумент. Вътре във функцията, използвайте filter() и анонимна (lambda) функция, за да филтрирате само четните числа от списъка. След това, използвайте map() и друга анонимна функция, за да удвоите стойността на всяко четно число. Накрая, функцията трябва да върне новия списък с удвоени четни числа.
Решение:
def double_even_numbers(numbers):
    even_numbers = filter(lambda x: x % 2 == 0, numbers)
    doubled_evens = map(lambda x: x * 2, even_numbers)
    return list(doubled_evens)

numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = double_even_numbers(numbers)
print(f"Оригинален списък: {numbers}")
print(f"Удвоени четни числа: {result}")
Тези казуси покриват основните аспекти на функциите в Python, включително различни начини за дефиниране и извикване на функции, работа с различни видове аргументи, връщане на стойности, както и използване на анонимни функции.


Въпроси:
1. Каква е целта на функциите в програмирането? Обяснете с прости думи. 
2. Как се дефинира функция в Python? Обяснете ключовата дума `def`, името на функцията, параметрите и тялото на функцията. 
3. Какво е документационен низ (docstring) и защо е важен? 
4. Обяснете различните видове аргументи в Python: позиционни, ключови, по подразбиране, `*args` и `**kwargs`. Дайте примери за всеки вид. 
5. Какво е `*args` и за какво се използва? 
6. Какво е `**kwargs` и за какво се използва? 
7. Каква е целта на оператора `return` във функция? Какво връща функция, ако няма `return` оператор? 
8. Обяснете концепцията за обхват на променливите в Python. Каква е разликата между локални и глобални променливи? 
9. Какво е правилото LEGB? 
10. Какво представляват анонимните (lambda) функции? В какви ситуации са полезни? 

Задачи:
1. Напишете функция, която приема две числа като аргументи и връща тяхната сума. 
2. Напишете функция, която приема низ като аргумент и връща неговата дължина. 
3. Напишете функция, която приема списък от числа като аргумент и връща най-голямото число в списъка. 
4. Напишете функция, която приема низ като аргумент и връща нов низ, в който всички главни букви са заменени с малки и обратното. 
5. Напишете функция, която приема число като аргумент и проверява дали е просто.
6. Напишете функция, която приема произволен брой низове като аргументи и ги обединява в един низ, разделени с интервали. 
7. Напишете функция, която приема речник като аргумент и извежда всички ключове и стойности в него. 
8. Напишете lambda функция, която приема число като аргумент и връща неговата трета степен. 
9. Напишете lambda функция, която приема число като аргумент и връща неговия корен квадратен.
10. Използвайте функцията `filter()` и lambda функция, за да филтрирате само нечетните числа от даден списък.
	Основи на обектно-ориентирано програмиране	(ООП)
  
Обектно-ориентираното програмиране (ООП) е парадигма за програмиране, която се основава на концепцията за "обекти", които могат да съдържат данни (под формата на атрибути или свойства) и код (под формата на методи или функции). ООП цели да моделира реалния свят по-близко, като организира кода около обекти, които взаимодействат помежду си. Основните принципи на ООП включват капсулиране, наследяване и полиморфизъм. В тази глава ще разгледаме основните концепции, свързани с класове и обекти.
	Концепция за класове и обекти
	Клас (Class): 
Класът може да се разглежда като blueprint (шаблон) за създаване на обекти. Той дефинира структурата и поведението на обектите, които ще бъдат създадени от него. Класът определя какви данни ще съдържат обектите (атрибути) и какви действия ще могат да извършват (методи). Можем да си представим класа като рецепта за приготвяне на нещо.
	Обект (Object) или Инстанция (Instance): 
Обектът е конкретна реализация (екземпляр) на даден клас. Когато създадем обект от клас, ние създаваме реална същност в паметта, която има атрибутите и методите, дефинирани в класа. Следвайки аналогията с рецептата, обектът е крайният продукт, приготвен по тази рецепта. Можем да създадем много обекти (инстанции) от един и същ клас, като всеки обект ще има свои собствени стойности за атрибутите си.
Например, можем да имаме клас Car (кола), който дефинира атрибути като model, color, year и методи като start(), stop(), accelerate(). След това можем да създадем множество обекти (инстанции) на класа Car, като всяка инстанция ще представлява конкретна кола с нейните специфични модел, цвят и година, но всички те ще имат общото поведение, дефинирано в класа Car (ще могат да стартират, спират и ускоряват).
	Дефиниране на клас (class)
За да дефинирате клас в Python, използвате ключовата дума class, последвана от името на класа (обикновено с главна буква по конвенция) и двоеточие :. Блокът код, който представлява тялото на класа, трябва да бъде отместен навътре.
class Dog:
    """Клас, представляващ куче."""
    pass  # Засега класът е празен
В този пример дефинирахме клас с име Dog. Ключовата дума pass се използва, когато синтактично е необходимо да има блок от код, но все още не сме решили какво ще съдържа класът.
	Атрибути и методи
	Атрибути (Attributes):
 	Атрибутите са данни, свързани с обектите на класа. Те представляват състоянието на обекта. Можем да си ги представим като променливи, които принадлежат на обекта.
	Методи (Methods): 
Методите са функции, които са дефинирани вътре в класа и описват поведението на обектите на класа. Те могат да достъпват и модифицират атрибутите на обекта. Първият параметър на всеки метод в класа обикновено е self, който представлява инстанцията (обекта), за която се извиква методът.
Ето пример, който добавя атрибути и метод към класа Dog:
class Dog:
    """Клас, представляващ куче с име и порода."""

    def __init__(self, name, breed):
        """Конструктор за инициализиране на обект Dog."""
        self.name = name
        self.breed = breed

    def bark(self):
        """Метод, който кара кучето да лае."""
        print("Woof!")

# Създаване на обекти (инстанции) на класа Dog
my_dog = Dog("Рекс", "Немска овчарка")
your_dog = Dog("Бела", "Лабрадор")

# Достъп до атрибутите на обектите
print(f"Моето куче се казва {my_dog.name} и е от порода {my_dog.breed}.")
# Извежда: Моето куче се казва Рекс и е от порода Немска овчарка.

print(f"Твоето куче се казва {your_dog.name} и е от порода {your_dog.breed}.")
# Извежда: Твоето куче се казва Бела и е от порода Лабрадор.

# Извикване на метода bark() на обектите
my_dog.bark()   # Извежда: Woof!
your_dog.bark() # Извежда: Woof!

	Конструктор (__init__)
Методът __init__ е специален метод в Python класовете. Той се нарича конструктор и се извиква автоматично, когато се създава нов обект (инстанция) на класа. Основната цел на __init__ е да инициализира атрибутите на новосъздадения обект. Първият параметър на __init__ винаги е self, а след него могат да следват други параметри, които получават стойностите, подадени при създаването на обекта.
В примера с класа Dog, __init__(self, name, breed) е конструкторът. Когато създаваме обект като my_dog = Dog("Рекс", "Немска овчарка"), стойността "Рекс" се присвоява на параметъра name, а "Немска овчарка" на breed. Вътре в __init__, self.name = name създава атрибут name за обекта my_dog и му присвоява стойността "Рекс". Аналогично се създава и атрибутът self.breed.
Пример:
Да разгледаме клас Circle (окръжност), който има атрибут radius (радиус). Конструкторът __init__ ще бъде използван, за да зададе стойността на радиуса при създаване на обект Circle.
class Circle:
    """Клас, представляващ окръжност с определен радиус."""

    def __init__(self, radius):
        """Конструктор за инициализиране на обект Circle с даден радиус."""
        self.radius = radius

    def area(self):
        """Метод за изчисляване на лицето на окръжността."""
        import math
        return math.pi * self.radius ** 2

# Създаване на обекти (инстанции) на класа Circle
circle1 = Circle(5)
circle2 = Circle(10)

# Достъп до атрибута radius на обектите
print(f"Радиусът на първата окръжност е: {circle1.radius}")
# Извежда: Радиусът на първата окръжност е: 5

print(f"Радиусът на втората окръжност е: {circle2.radius}")
# Извежда: Радиусът на втората окръжност е: 10

# Извикване на метода area() за изчисляване на лицето
area1 = circle1.area()
print(f"Лицето на първата окръжност е: {area1:.2f}")
# Извежда: Лицето на първата окръжност е: 78.54

area2 = circle2.area()
print(f"Лицето на втората окръжност е: {area2:.2f}")
# Извежда: Лицето на втората окръжност е: 314.16

	Декоратори, свързани с класове и методи
Python предлага няколко вградени декоратора, които са особено полезни при дефинирането на класове и техните методи. Тези декоратори променят поведението на методите по специфичен начин.
	@staticmethod: Този декоратор се използва за дефиниране на статични методи в клас. Статичният метод не приема автоматично инстанцията на класа (self) като първи аргумент, нито класа (cls). Той се държи като обикновена функция, която е логически свързана с класа. Статичните методи често се използват за помощни функции, които са релевантни към класа, но не зависят от конкретно състояние на неговите инстанции.
class MathUtils:
    @staticmethod
    def add(x, y):
        return x + y

    @staticmethod
    def is_positive(num):
        return num > 0

print(MathUtils.add(5, 3))
print(MathUtils.is_positive(-2))
	@classmethod: Този декоратор се използва за дефиниране на методи на клас. Методите на клас приемат самия клас (cls) като първи аргумент (вместо инстанцията self). Те могат да бъдат извиквани както от самия клас, така и от негови инстанции, и често се използват за създаване на фабрични методи (алтернативни конструктори) или за извършване на операции, които са свързани с класа като цяло.
class Person:
    count = 0

    def __init__(self, name, age):
        self.name = name
        self.age = age
        Person.count += 1

    @classmethod
    def get_total_people(cls):
        return cls.count

    @classmethod
    def create_anonymous(cls, age):
        return cls("Anonymous", age)

person1 = Person("Alice", 30)
person2 = Person("Bob", 25)

print(Person.get_total_people())
anonymous_person = Person.create_anonymous(20)
print(anonymous_person.name)
print(Person.get_total_people())
	@property: Този декоратор се използва за дефиниране на свойства (properties) на клас. Той превръща метод в атрибут, към който може да се достъпва без скоби, сякаш е обикновена променлива. @property често се използва за контролиране на достъпа до атрибути на клас (например, за да направите атрибут само за четене) или за извършване на допълнителна логика при достъпване на атрибута. Могат да се дефинират и методи за задаване (@име_на_свойство.setter), изтриване (@име_на_свойство.deleter) на стойността на свойството.
class Circle:
    def __init__(self, radius):
        self._radius = radius

    @property
    def radius(self):
        """Получава радиуса на кръга."""
        return self._radius

    @radius.setter
    def radius(self, value):
        """Задава радиуса на кръга, валидирайки стойността."""
        if value >= 0:
            self._radius = value
        else:
            raise ValueError("Радиусът трябва да бъде неотрицателно число.")

    @property
    def area(self):
        """Изчислява и връща площта на кръга (само за четене)."""
        return 3.14159 * self._radius ** 2

circle = Circle(5)
print(circle.radius)
print(circle.area)

circle.radius = 7
print(circle.radius)
print(circle.area)

# circle.area = 100 # Ще предизвика AttributeError, защото няма setter за area
	Разбирането и използването на тези декоратори може значително да подобри структурата и четимостта на вашите Python класове, както и да предостави по-гъвкав контрол върху поведението на техните методи и атрибути.

	Наследяване (кратко въведение)
Наследяването е механизъм в ООП, който позволява на един клас (наречен подклас или клас-наследник) да наследи атрибутите и методите на друг клас (наречен суперклас или базов клас). Подкласът може да добавя нови атрибути и методи или да предефинира (override) наследени методи, за да промени тяхното поведение. Наследяването е мощен инструмент за повторно използване на код и за създаване на йерархии от класове, които имат общи характеристики и специфични разлики.
Ето прост пример за наследяване:
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("Някакъв звук")

class Cat(Animal):
    def speak(self):
        print("Мяу")

class Dog(Animal):
    def speak(self):
        print("Бау")

my_animal = Animal("Животно")
my_cat = Cat("Маца")
my_dog = Dog("Шаро")

my_animal.speak() # Извежда: Някакъв звук
my_cat.speak()    # Извежда: Мяу
my_dog.speak()    # Извежда: Бау
В този пример Cat и Dog са подкласове на Animal. Те наследяват атрибута __init__ (и по този начин атрибута name) и предефинират метода speak(), за да предоставят специфично за тях поведение.
	Извикване на метода на суперкласа с super():
Един важен аспект на наследяването е възможността подкласът да използва (или разшири) функционалността на метода на суперкласа. Това се постига с вградената функция super(). Тя позволява да се извика метод от родителския клас. Това е особено полезно, когато искате да добавите специфично поведение към наследен метод, но все пак да запазите оригиналната му функционалност.
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        print("Някакъв звук")

class Cat(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # Извикване на __init__ на суперкласа
        self.breed = breed

    def speak(self):
        super().speak()       # Извикване на speak() на суперкласа
        print("Мяу")

my_cat = Cat("Маца", "Персийска")
my_cat.speak()
print(my_cat.name)
print(my_cat.breed)
В този пример, Cat.__init__ първо извиква Animal.__init__ с помощта на super(), за да инициализира атрибута name, след което добавя специфичния за Cat атрибут breed. Аналогично, Cat.speak() първо извиква Animal.speak(), за да изведе общия звук, и след това добавя специфичното "Мяу".
	Множествено наследяване (Multiple Inheritance):
Python поддържа множествено наследяване, което означава, че един клас може да наследи атрибути и методи от няколко суперкласа. Това може да бъде мощен инструмент, но трябва да се използва внимателно, тъй като може да доведе до сложност и проблеми като "ромбовидно наследяване" (Diamond Problem), където един клас наследява един и същ метод от два различни родителски класа, които пък наследяват общ прародителски клас.
class Swimmer:
    def swim(self):
        print("Плува")

class Walker:
    def walk(self):
        print("Ходи")

class Amphibian(Swimmer, Walker):
    pass

frog = Amphibian()
frog.swim()
frog.walk()
В този пример, класът Amphibian наследява както Swimmer, така и Walker, като по този начин придобива и двата метода swim() и walk().
	Mетод за разрешаване на реда (Method Resolution Order - MRO):
При множествено наследяване, когато се извиква метод, който е дефиниран в повече от един суперклас, Python използва MRO, за да определи кой метод да бъде изпълнен. MRO следва правилото C3 linearisation, което гарантира предвидимо и последователно разрешаване на методите. Можете да видите MRO на даден клас, като използвате атрибута __mro__ или метода mro().
class A:
    def greet(self):
        print("Здравей от A")

class B:
    def greet(self):
        print("Здравей от B")

class C(A, B):
    pass

class D(B, A):
    pass

c_instance = C()
c_instance.greet()  # Извежда: Здравей от A (защото A е първи в реда на наследяване)
print(C.__mro__)    # Показва реда на търсене на методи

d_instance = D()
d_instance.greet()  # Извежда: Здравей от B (защото B е първи в реда на наследяване)
print(D.__mro__)    # Показва реда на търсене на методи

	Защитени (Protected) и Частни (Private) членове
В обектно-ориентираното програмиране е важен принципът на капсулиране (encapsulation), който цели да скрие вътрешното състояние на обекта и да контролира достъпа до него. В Python има конвенции, които указват нивото на достъпност на атрибутите и методите на класа:
	Публични (Public) членове: Това са атрибути и методи, до които може да се достъпва свободно отвсякъде – както вътре в класа, така и извън него (чрез инстанция на класа). Името на публичните членове не започва с долна черта.
	Защитени (Protected) членове: Конвенцията в Python е, че атрибутите и методите, чието име започва с една долна черта (_), се считат за защитени. Това означава, че те са предназначени за използване вътре в класа и неговите подкласове (при наследяване). Въпреки че Python не забранява достъпа до тях извън класа, се приема, че това е "неписано правило" и програмистите трябва да бъдат внимателни при директното им модифициране или използване извън контекста на класа и неговите наследници.

class Parent:
    def __init__(self):
        self.public_attribute = "Аз съм публичен"
        self._protected_attribute = "Аз съм защитен"

    def public_method(self):
        print("Това е публичен метод")
        self._protected_method()

    def _protected_method(self):
        print("Това е защитен метод")

class Child(Parent):
    def access_protected(self):
        print(f"Достъп до защитен атрибут от подклас: {self._protected_attribute}")
        self._protected_method()

parent_instance = Parent()
child_instance = Child()

print(parent_instance.public_attribute)  # Достъп разрешен
parent_instance.public_method()        # Достъп разрешен

print(child_instance.public_attribute)    # Достъп разрешен от подклас
child_instance.public_method()          # Достъп разрешен от подклас
child_instance.access_protected()          # Достъп разрешен от подклас

print(parent_instance._protected_attribute) # Въпреки конвенцията, достъпът е възможен (но не се препоръчва)
parent_instance._protected_method()       # Въпреки конвенцията, достъпът е възможен (но не се препоръчва)
	Частни (Private) членове: Атрибутите и методите, чието име започва с две долни черти (__), се считат за частни. Python прилага механизъм, наречен name mangling, който преименува тези членове, за да затрудни случайния достъп до тях извън класа. Целта е да се предотврати неволна модификация на вътрешното състояние на обекта. Въпреки това, те не са напълно недостъпни – могат да бъдат достъпени с малко по-сложен синтаксис (_ИмеКлас__име_на_член).
class Example:
    def __init__(self):
        self.public_attribute = "Публичен"
        self.__private_attribute = "Частен"

    def public_method(self):
        print("Публичен метод")
        self.__private_method()

    def __private_method(self):
        print("Частен метод")

example_instance = Example()
print(example_instance.public_attribute)  # Достъп разрешен
example_instance.public_method()        # Достъп разрешен (извиква частен метод вътрешно)

# print(example_instance.__private_attribute) # Ще предизвика AttributeError
# example_instance.__private_method()       # Ще предизвика AttributeError

print(example_instance._Example__private_attribute) # Достъп до частен атрибут (name mangling)
example_instance._Example__private_method()       # Достъп до частен метод (name mangling)

Разбирането на тези конвенции за достъпност е важно за писане на по-добре структуриран и поддържащ се обектно-ориентиран код в Python. Въпреки че Python не налага строги ограничения за достъп, следването на тези конвенции е силно препоръчително.

	Абстрактни класове и методи (Abstract Classes and Methods):
Python позволява дефинирането на абстрактни класове и методи с помощта на модула abc (Abstract Base Classes). Абстрактните класове не могат да бъдат инстанцирани директно и служат като основа за други класове. Абстрактните методи са декларирани в абстрактен клас, но нямат имплементация в него. Подкласовете, които наследяват абстрактен клас, трябва да имплементират всички негови абстрактни методи, в противен случай и те ще бъдат абстрактни.
Абстрактните класове и методи се използват за дефиниране на интерфейси и осигуряване на определено поведение в йерархията от класове.
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def perimeter(self):
        return 2 * (self.width + self.height)

# shape = Shape() # Ще предизвика TypeError, защото Shape е абстрактен клас

rectangle = Rectangle(5, 10)
print(f"Площ: {rectangle.area()}")
print(f"Периметър: {rectangle.perimeter()}")
В този пример Shape е абстрактен клас с два абстрактни метода (area и perimeter). Класът Rectangle наследява Shape и предоставя конкретна имплементация на тези методи.
	Полиморфизъм (Polymorphism):
Полиморфизмът е една от четирите основни парадигми на обектно-ориентираното програмиране (наред с капсулирането, наследяването и абстракцията). Буквално означава "много форми" и се отнася до способността на обекти от различни класове да отговарят на едно и също съобщение (извикване на метод) по свой собствен, специфичен начин.
Същността на полиморфизма се крие в идеята, че можете да работите с обекти от различни класове по един и същ начин, стига те да споделят общ интерфейс (обикновено чрез наследяване от общ суперклас или имплементиране на общ абстрактен клас). Това позволява писането на по-гъвкав, по-обобщен и по-лесно разширяем код.
	Видове полиморфизъм:
В Python полиморфизмът се постига основно чрез:
	Duck Typing (Динамично типизиране): Python е динамично типизиран език, което означава, че типът на променливата се определя по време на изпълнение, а не по време на компилация. "Ако изглежда като патица, кряка като патица, значи вероятно е патица." В контекста на полиморфизма, това означава, че ако един обект има необходимите методи и атрибути, можем да го третираме като обект от определен тип, независимо от неговия действителен клас.
	Наследяване и предефиниране на методи (Method Overriding): Както видяхме в темата за наследяването, подкласовете могат да предефинират методи, наследени от техните суперкласове, за да предоставят специфична за тях имплементация. Това позволява на обекти от различни класове в една йерархия да отговарят на едно и също извикване на метод по различен начин.
	Абстрактни класове и методи: Абстрактните класове дефинират интерфейс (набор от методи), които техните подкласове трябва да имплементират. Това гарантира, че обекти от различни конкретни класове, наследяващи един и същ абстрактен клас, ще имат определени общи методи, макар и с различна имплементация.
	Примери за полиморфизъм:
	Полиморфизъм чрез наследяване и предефиниране на методи:
class Animal:
    def speak(self):
        print("Някакъв звук")

class Cat(Animal):
    def speak(self):
        print("Мяу")

class Dog(Animal):
    def speak(self):
        print("Бау")

def animal_sound(animal):
    animal.speak()

my_cat = Cat("Маца")
my_dog = Dog("Шаро")
my_animal = Animal("Животно")

animal_sound(my_cat)    # Извежда: Мяу
animal_sound(my_dog)    # Извежда: Бау
animal_sound(my_animal) # Извежда: Някакъв звук
В този пример, функцията animal_sound приема обект от тип Animal (или негов подклас). Въпреки че подаваме обекти от различни класове (Cat, Dog, Animal), всички те имат метод speak(), който се изпълнява по специфичен за техния клас начин.

	Полиморфизъм чрез Duck Typing:
class Bird:
    def fly(self):
        print("Птицата лети.")

class Airplane:
    def fly(self):
        print("Самолетът лети.")

class Superman:
    def fly(self):
        print("Супермен лети!")

def make_it_fly(flying_object):
    flying_object.fly()

bird = Bird()
plane = Airplane()
superman = Superman()

make_it_fly(bird)     # Извежда: Птицата лети.
make_it_fly(plane)    # Извежда: Самолетът лети.
make_it_fly(superman) # Извежда: Супермен лети!
Тук функцията make_it_fly не проверява изрично типа на подадения обект. Тя просто очаква обектът да има метод fly(). Класовете Bird, Airplane и Superman имат такъв метод, и затова функцията може да работи с обекти от тези различни класове.
	Полиморфизъм чрез абстрактни класове и методи:
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14159 * self.radius ** 2

def print_area(shape):
    print(f"Площта е: {shape.area()}")

rectangle = Rectangle(5, 10)
circle = Circle(7)

print_area(rectangle) # Извежда: Площта е: 50
print_area(circle)    # Извежда: Площта е: 153.93804
В този случай, Shape е абстрактен клас, който дефинира абстрактния метод area(). Класовете Rectangle и Circle наследяват Shape и имплементират метода area() по специфичен за тях начин. Функцията print_area приема обект от тип Shape (или негов подклас) и може да работи с обекти от различни конкретни класове, стига те да имплементират метода area().
	Значение на полиморфизма:
	Гъвкавост: Позволява писането на код, който може да работи с обекти от различни класове по унифициран начин.
	Разширяемост: Лесно е да се добавят нови класове към системата, без да се налага да се променя съществуващият код, стига новите класове да спазват общия интерфейс.
	Повторно използване на код: Обобщените функции и класове могат да работят с множество различни типове обекти.
	По-добра поддръжка: Кодът, който използва полиморфизъм, е по-лесен за разбиране и поддръжка, тъй като се фокусира върху поведението (методите), а не върху конкретния тип на обекта.

	Инкапсулация (Encapsulation) - повторно разглеждане с по-голям акцент:
Инкапсулацията е ключов принцип в обектно-ориентираното програмиране, който се фокусира върху скриването на вътрешното състояние (данни, атрибути) на обекта и предоставянето на контролиран достъп до него чрез публични методи (методи на интерфейса). Целта на инкапсулацията е да предпази вътрешните данни на обекта от пряка и неконтролирана външна намеса, което може да доведе до неочаквани състояния и грешки.
В Python, инкапсулацията се постига основно чрез конвенции за именуване (както вече разгледахме със защитените и частните членове) и чрез използването на методи за достъп и модификация на атрибутите. Декораторът @property е мощен инструмент за реализиране на контролиран достъп, подобен на концепцията за "getters" и "setters" в други езици, но по по-Pythonic начин.

Пример, илюстриращ инкапсулацията с @property:

Представете си клас Car, който има атрибут за скорост (_speed). Искаме да контролираме как скоростта може да бъде задавана и да предотвратим задаването на отрицателна скорост. Също така, искаме да предоставим начин за получаване на текущата скорост.
class Car:
    def __init__(self, model):
        self.model = model
        self._speed = 0  # Вътрешен атрибут, започващ с _, което подсказва защитен достъп

    @property
    def speed(self):
        """Получава текущата скорост на колата."""
        return self._speed

    @speed.setter
    def speed(self, new_speed):
        """Задава скоростта на колата, като валидира стойността."""
        if new_speed >= 0:
            self._speed = new_speed
        else:
            print("Внимание: Скоростта не може да бъде отрицателна. Скоростта остава непроменена.")

    def accelerate(self, increment):
        self.speed += increment  # Използва setter-а за контролирана промяна

    def brake(self, decrement):
        self.speed -= decrement  # Използва setter-а за контролирана промяна

my_car = Car("Toyota")
print(f"Начална скорост: {my_car.speed}")  # Достъпва скоростта чрез getter-а (@property)

my_car.speed = 50  # Задава скоростта чрез setter-а (@speed.setter)
print(f"Текуща скорост след задаване: {my_car.speed}")

my_car.accelerate(20)
print(f"Скорост след ускорение: {my_car.speed}")

my_car.speed = -10  # Опит за задаване на невалидна скорост
print(f"Скорост след опит за отрицателна стойност: {my_car.speed}")

my_car._speed = -100 # Директна промяна на "защитен" атрибут - Python го позволява, но не се препоръчва
print(f"Скорост след директна (неправилна) промяна: {my_car._speed}")
Как този пример илюстрира инкапсулацията:
	Скриване на вътрешното състояние: Атрибутът _speed е именуван с долна черта, което подсказва, че е предназначен за вътрешна употреба в класа. Въпреки че можем да го достъпим директно отвън, конвенцията ни съветва да не го правим.
	Контролиран достъп чрез методи: Вместо да позволяваме пряко задаване на стойност на _speed, ние предоставяме публичен интерфейс чрез свойството speed (с помощта на @property и @speed.setter).
	Валидация на данните: Setter методът speed(self, new_speed) прилага логика за валидиране на входящата стойност, като предотвратява задаването на отрицателна скорост. Това гарантира, че обектът Car винаги поддържа валидно състояние.
	Интегрирано поведение: Методите accelerate и brake също използват setter-а self.speed = ..., осигурявайки консистентно прилагане на правилата за скорост.
	Чрез инкапсулацията, ние правим класа Car по-ясен и по-лесен за поддръжка. Ако по-късно решим да променим начина, по който се съхранява или валидира скоростта, можем да направим това вътре в класа, без да се налага да променяме кода, който използва класа (стига публичният интерфейс speed да остане същият). Това е една от основните ползи на инкапсулацията – абстракция и защита от външни промени.

	Композиция (Composition) vs. Наследяване (Inheritance):
Важно е да се спомене, че наследяването не е единственият начин за повторно използване на код и изграждане на сложни обекти. Композицията (обект съдържа други обекти като свои членове) е друга мощна техника, която често е по-гъвкава и води до по-слабо свързан код. 
При проектирането на обектно-ориентирани системи често възниква въпросът как най-добре да се постигне повторно използване на код и да се изградят сложни обекти от по-прости. Два основни механизма за това са наследяването (inheritance) и композицията (composition). Разбирането на техните силни и слаби страни е ключово за вземане на правилни архитектурни решения.
	Наследяване (Inheritance): "Е вид на" (Is-a) връзка
Както вече разгледахме, наследяването е механизъм, при който един клас (подклас) придобива атрибутите и методите на друг клас (суперклас). То създава йерархия от класове, където подкласът е специализирана версия на суперкласа и установява "е вид на" (is-a) връзка.
	Предимства на наследяването:
	Повторно използване на код: Подкласът автоматично наследява функционалността на суперкласа, което намалява дублирането на код.
	Йерархична структура: Наследяването естествено моделира йерархични връзки между обекти (например, Cat е вид Animal).
	Полиморфизъм: Подкласовете могат да предефинират наследени методи, което позволява полиморфно поведение.
	Недостатъци на наследяването:
	Тясна свързаност (Tight Coupling): Подкласът става силно зависим от имплементацията на суперкласа. Промените в суперкласа могат да имат непредвидени последствия за подкласовете.
	Нарушаване на принципа на единична отговорност (Single Responsibility Principle): Понякога наследяването може да принуди подклас да наследи функционалност, която не му е необходима.
	Проблем с множественото наследяване: Както вече споменахме, множественото наследяване може да доведе до сложност и трудности при разрешаването на методи (Diamond Problem).
	Трудност при промяна на типа по време на изпълнение: Типът на обект, създаден чрез наследяване, е фиксиран по време на неговото създаване и не може лесно да бъде променен.
	Композиция (Composition): "Има част от" (Has-a) връзка
Композицията е друг начин за повторно използване на код, при който един клас съдържа инстанции на други класове като свои атрибути. Това създава "има част от" (has-a) връзка между класовете. Вместо да наследява поведение, класът делегира определени задачи на своите съставни обекти.
	Предимства на композицията:
	Слаба свързаност (Loose Coupling): Класовете, които се композират, са по-независими един от друг. Промените в един клас е по-малко вероятно да засегнат другите.
	Принцип на единична отговорност: Всеки клас може да се фокусира върху една конкретна отговорност, а сложните поведения се изграждат чрез комбиниране на отговорностите на съставните обекти.
	Гъвкавост по време на изпълнение: Възможно е да се променя поведението на обект по време на изпълнение, като се заменят неговите съставни обекти.
	По-лесно тестване: Тъй като класовете са по-слабо свързани, те могат да бъдат тествани по-изолирано.
	Недостатъци на композицията:
	Повече код за делегиране: Може да се наложи да се напише повече код за препращане на извиквания към съставните обекти.
	По-сложна структура: При много сложни системи, композицията може да доведе до по-разклонена структура от обекти.
	Пример за сравнение: Изграждане на кола
Да разгледаме пример за изграждане на клас Car, използвайки както наследяване, така и композиция:
Наследяване:
class Engine:
    def start(self):
        print("Двигателят работи")

class Wheels:
    def rotate(self):
        print("Колелата се въртят")

class Car(Engine, Wheels):  # Наследява Engine и Wheels
    def drive(self):
        self.start()
        self.rotate()
        print("Колата се движи")

my_car_inheritance = Car()
my_car_inheritance.drive()
В този случай, Car "е вид" Engine и "е вид" Wheels, което е семантично неправилно. Колата не е двигател или колела, а има двигател и колела.
Композиция:
class Engine:
    def start(self):
        print("Двигателят работи")

class Wheels:
    def rotate(self):
        print("Колелата се въртят")

class Car:
    def __init__(self):
        self.engine = Engine()  # Колата има двигател
        self.wheels = [Wheels() for _ in range(4)] # Колата има колела

    def drive(self):
        self.engine.start()
        for wheel in self.wheels:
            wheel.rotate()
        print("Колата се движи")

my_car_composition = Car()
my_car_composition.drive()
В този случай, Car "има" Engine и "има" списък от Wheels. Това по-добре отразява реалната връзка между колата и нейните компоненти.
	Кога да използваме кое?
	Наследяване: Използвайте наследяване, когато има ясна "е вид на" (is-a) връзка и искате да се възползвате от полиморфизъм и йерархична структура. Използвайте го внимателно и се уверете, че подкласът наистина е специализация на суперкласа.
	Композиция: Използвайте композиция, когато има "има част от" (has-a) връзка и искате да постигнете по-слаба свързаност, по-голяма гъвкавост и по-добро спазване на принципа на единична отговорност. Често композицията е предпочитан подход за повторно използване на код, тъй като води до по-гъвкави и устойчиви на промени системи.
В много случаи, добрите обектно-ориентирани дизайни използват комбинация от наследяване и композиция, за да постигнат баланс между повторно използване на код и гъвкавост.


	Това е само кратко въведение в основите на обектно-ориентираното програмиране в Python. ООП е обширна тема и има още много концепции за разглеждане, но тези основи ще ви помогнат да започнете да разбирате и използвате класове и обекти във вашите програми.

Казус 1: Създаване на клас "Кръг"
Дефинирайте клас Circle, който има следните характеристики:
	Атрибут: radius (радиус на кръга).
	Конструктор (__init__): Приема радиус като аргумент и го присвоява на атрибута radius.
	Методи: 
	area(): Връща площта на кръга (π∗r²).
	circumference(): Връща обиколката на кръга (2∗π∗r).
Създайте два обекта от класа Circle с различни радиуси и изведете техните площи и обиколки.
Решение:
import math

class Circle:
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius ** 2

    def circumference(self):
        return 2 * math.pi * self.radius

# Създаване на обекти
circle1 = Circle(5)
circle2 = Circle(10)

# Извеждане на резултати
print(f"Кръг 1 - Радиус: {circle1.radius}, Площ: {circle1.area():.2f}, Обиколка: {circle1.circumference():.2f}")
print(f"Кръг 2 - Радиус: {circle2.radius}, Площ: {circle2.area():.2f}, Обиколка: {circle2.circumference():.2f}")

Казус 2: Създаване на клас "Правоъгълник"
Дефинирайте клас Rectangle, който има следните характеристики:
	Атрибути: width (ширина) и height (височина).
	Конструктор (__init__): Приема ширина и височина като аргументи и ги присвоява на съответните атрибути.
	Метод: area(): Връща площта на правоъгълника (ширина * височина).
Създайте обект от класа Rectangle и изведете неговата площ.
Решение:
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Създаване на обект
rectangle = Rectangle(7, 4)

# Извеждане на резултата
print(f"Правоъгълник - Ширина: {rectangle.width}, Височина: {rectangle.height}, Площ: {rectangle.area()}")

Казус 3: Създаване на клас "Автомобил" с наследяване
Дефинирайте базов клас Vehicle със следните характеристики:
	Атрибут: brand (марка).
	Конструктор (__init__): Приема марка като аргумент и я присвоява на атрибута brand.
	Метод: display_info(): Извежда информация за марката на превозното средство.
След това дефинирайте клас Car, който наследява Vehicle и има допълнителен атрибут model (модел) и предефинира метода display_info(), за да изведе марката и модела на автомобила.
Създайте обект от класа Car и извикайте неговия метод display_info().
class Vehicle:
    def __init__(self, brand):
        self.brand = brand

    def display_info(self):
        print(f"Марка: {self.brand}")

class Car(Vehicle):
    def __init__(self, brand, model):
        super().__init__(brand)  # Извикване на конструктора на базовия клас
        self.model = model

    def display_info(self):
        print(f"Марка: {self.brand}, Модел: {self.model}")

# Създаване на обект
my_car = Car("Toyota", "Corolla")

# Извикване на метода
my_car.display_info()


	Тези казуси въвеждат основните концепции на ООП чрез прости примери. Първите два казуса се фокусират върху дефинирането на класове с атрибути и методи, както и използването на конструктор. Третият казус дава кратко въведение в наследяването, показвайки как един клас може да наследи атрибути и методи от друг клас и да ги разшири или предефинира.
 
Въпроси:
	Какво е обектно-ориентирано програмиране (ООП)? Кои са основните му цели?
	Обяснете концепцията за клас и обект. Каква е връзката между тях? Дайте аналогия от реалния свят.
	Как се дефинира клас в Python? Какво представлява тялото на класа?
	Какво са атрибути на клас и обект? Дайте примери.
	Какво са методи на клас? Какъв е първият параметър на всеки метод по конвенция? За какво се използва той?
	Какво е конструктор (__init__)? Кога се извиква той? Каква е основната му цел?
	Обяснете концепцията за наследяване в ООП. Защо е полезно? Дайте прост пример.

Задачи:
	Дефинирайте клас Rectangle (правоъгълник) с атрибути width (ширина) и height (височина). Добавете метод area(), който изчислява и връща лицето на правоъгълника. Създайте обект от класа Rectangle и изведете неговото лице.
	Дефинирайте клас GSM (мобилен телефон) с атрибути model (модел - низ), manufacturer (производител - низ) и has_camera (има ли камера - булев тип). Добавете следните методи: display_info(): Метод, който извежда на конзолата информация за GSM-а във формат: "Модел: [модел], Производител: [производител], Камера: [Да/Не]"; .take_photo(): Метод, който проверява дали телефонът има камера. Ако има, извежда съобщение "Снимката е направена.", в противен случай извежда "Телефонът няма камера и не може да направи снимка.". Създайте два различни обекта от класа GSM с различни модели, производители и информация за камера. Извикайте метода display_info() за всеки обект, за да покажете информацията им. След това извикайте метода take_photo() за всеки обект, за да демонстрирате функционалността му.
	Дефинирайте клас BankAccount (банкова сметка) с атрибут balance (баланс) и методи deposit(amount) (внос) и withdraw(amount) (теглене). Конструкторът трябва да инициализира баланса на 0. Направете няколко вноса и тегления и изведете текущия баланс.
	Създайте клас Student (студент) с атрибути name (име) и grades (списък с оценки). Добавете метод average_grade(), който изчислява и връща средната оценка на студента. Създайте обект Student, добавете няколко оценки и изведете средната оценка.
	Дефинирайте клас Shape (фигура) с метод area(), който връща 0 (като базов случай). Създайте два подкласа Circle (окръжност) с атрибут radius и Rectangle (правоъгълник) с атрибути width и height. Предефинирайте метода area() във всеки подклас, за да изчислява съответното лице. Създайте обекти от двата подкласа и изведете техните лица.
	Дефинирайте два класа: Book (Книга) и Library (Библиотека).
Клас Book:
	Конструктор (__init__), който приема и инициализира следните атрибути: 
	title (заглавие) - стринг
	author (автор) - стринг
	publisher (издателство) - стринг
	year (година на издаване) - цяло число
	isbn (ISBN номер) - стринг
	Дефинирайте метод __str__, който връща четим стринг, описващ информацията за книгата (например: "Заглавие: [Заглавие], Автор: [Автор], ...").
Клас Library:
	Конструктор (__init__), който приема и инициализира: 
	name (име на библиотеката) - стринг
	books (списък с книги) - празен списък по подразбиране.
	Дефинирайте следните методи: 
	add_book(book): приема обект от клас Book и го добавя към списъка books.
	search_by_author(author): приема стринг author и връща списък с всички книги в библиотеката, написани от този автор.
	display_book_info(isbn): приема стринг isbn и търси книга с този ISBN. Ако бъде намерена, извежда информацията за книгата, използвайки метода __str__ на обекта Book. Ако не бъде намерена, извежда подходящо съобщение.
	remove_book(isbn): приема стринг isbn и премахва книгата с този ISBN от списъка books, ако съществува. Извежда подходящо съобщение за успех или неуспех.
	Напишете примерен код, който демонстрира използването на класовете Book и Library  и техните методи, като създадете библиотека, добавите няколко книги, извършите търсене, изведете информация и премахнете книга.

ВЪПРОСИ И ЗАДАЧИ (ООП - Напреднали)
	Обяснете разликата между статичен метод (@staticmethod) и метод на клас (@classmethod). В какви ситуации бихте използвали всеки от тях?
	Каква е целта на декоратора @property? Обяснете как се използват @име_на_свойство.setter и @име_на_свойство.deleter. Дайте пример за ползите от използването на @property.
	Каква е конвенцията в Python за обозначаване на защитени членове на клас? Каква е разликата между защитени и частни членове (с двойна долна черта)? Каква е целта на name mangling при частните членове?
	Обяснете концепцията за полиморфизъм в ООП. Дайте примери как полиморфизмът се проявява в Python чрез наследяване и duck typing.
	Какво е инкапсулация и защо е важна в ООП? Как Python реализира инкапсулация (чрез конвенции и @property)? Обяснете ползите от инкапсулирането.
	Сравнете и контрастирайте композицията и наследяването като механизми за повторно използване на код в ООП. Обяснете връзките "е вид на" (is-a) и "има част от" (has-a). Кога е по-подходящо да се използва композиция, а кога наследяване?
	Създайте клас TemperatureConverter. Той трябва да има статичен метод celsius_to_fahrenheit(celsius), който преобразува градуси по Целзий във Фаренхайт, и метод на клас from_fahrenheit(fahrenheit), който създава инстанция на класа TemperatureConverter от дадена температура по Фаренхайт (вътрешно да съхранява температурата по Целзий).
	Създайте клас DataProcessor, който има вътрешен (защитен) списък _data. Предоставете публичен метод add_data(item) за добавяне на елементи към списъка и @property за достъп до дължината на списъка (data_length). Опитайте да промените директно _data отвън и обсъдете резултата.
	Дефинирайте базов клас Shape с абстрактен метод area(). Създайте два подкласа Rectangle и Circle, които наследяват Shape и имплементират метода area() за съответните фигури. Напишете функция, която приема обект от тип Shape и извежда неговата площ (демонстрирайки полиморфизъм).
	Създайте клас Engine с метод start() и клас Car с атрибут engine (инстанция на Engine). Класът Car трябва да има метод start_engine(), който извиква метода start() на своя engine. Това е пример за композиция. Разширете примера, като добавите клас ElectricEngine с различно поведение на start(), и покажете как лесно можете да смените двигателя на колата (гъвкавост на композицията).
	Създайте клас Person с атрибути name и age. Създайте подклас Employee, който наследява Person и добавя атрибут employee_id и метод get_details(), който връща информация за служителя. Създайте и клас Student, който наследява Person и добавя атрибут student_id и метод get_details(), който връща информация за студента. Демонстрирайте полиморфизъм, като създадете функция, която приема обект от тип Person и извиква неговия метод get_details() (ако съществува).

	Обработка на Изключения в Python
 

По време на изпълнението на една програма могат да възникнат грешки, известни като изключения (exceptions). Тези грешки могат да бъдат причинени от различни фактори, като например опит за деление на нула, опит за достъп до несъществуващ файл, грешен тип вход от потребителя и много други. Ако не бъдат обработени, изключенията могат да доведат до внезапно спиране на програмата и показване на съобщение за грешка (traceback).
Python предоставя механизъм за обработване на изключения (exception handling), който позволява да предвидите потенциални грешки, да ги "уловите" и да реагирате на тях по контролиран начин, вместо програмата да се срине. Това става с помощта на блоковете try, except, else и finally.
	try и except блокове
Основният начин за обработка на изключения е чрез използване на try и except блокове. Кодът, за който смятате, че може да предизвика изключение, се поставя вътре в try блок. Ако по време на изпълнението на кода в try блока възникне изключение, Python незабавно прекъсва изпълнението на този блок и търси съответстващ except блок, който да обработи възникналото изключение.
try:
    numerator = int(input("Въведете числител: "))
    denominator = int(input("Въведете знаменател: "))
    result = numerator / denominator
    print(f"Резултатът е: {result}")
except ZeroDivisionError:
    print("Грешка: Деление на нула не е позволено!")
except ValueError:
    print("Грешка: Моля, въведете валидно цяло число!")

В този пример:
	Кодът, който може да предизвика ZeroDivisionError (при деление на нула) или ValueError (ако потребителят въведе нещо, което не е цяло число), е поставен в try блока.
	Ако възникне ZeroDivisionError, се изпълнява кодът в първия except блок.
	Ако възникне ValueError, се изпълнява кодът във втория except блок.
	Ако не възникне нито едно от тези изключения, except блоковете се пропускат и се изпълнява кодът след тях.
Можете да имате множество except блокове, за да обработвате различни видове изключения по различен начин. Ако възникне изключение, което не е "уловено" от нито един от except блоковете, то ще продължи да се разпространява и може да доведе до спиране на програмата, ако не бъде обработено на по-високо ниво.
Съществува и възможност да "уловите" всички видове изключения с един except блок, но това обикновено не се препоръчва, тъй като може да скрие неочаквани грешки и да затрудни отстраняването на проблеми.


try:
    # Някакъв код, който може да предизвика изключение
    result = 10 / 0
except:
    print("Възникна някаква грешка!")
	else блок
Блокът else може да бъде добавен след един или повече except блокове. Кодът в else блока се изпълнява само ако не е възникнало изключение в try блока.
try:
    numerator = int(input("Въведете числител: "))
    denominator = int(input("Въведете знаменател: "))
    result = numerator / denominator
except ZeroDivisionError:
    print("Грешка: Деление на нула не е позволено!")
except ValueError:
    print("Грешка: Моля, въведете валидно цяло число!")
else:
    print(f"Резултатът от делението е: {result}")
	В този случай, съобщението за резултата ще бъде изведено само ако не е възникнала грешка при преобразуването на входа към цяло число или при делението.
	finally блок	
Блокът finally е опционален и се поставя след try (и евентуално except и else блокове). Кодът в finally блока винаги се изпълнява, независимо дали е възникнало изключение в try блока или не. finally често се използва за почистване на ресурси, като затваряне на файлове или освобождаване на връзки, които са били отворени в try блока.
file = None
try:
    file = open("my_file.txt", "r")
    content = file.read()
    print(content)
except FileNotFoundError:
    print("Грешка: Файлът не беше намерен!")
finally:
    if file is not None:
        file.close()
        print("Файлът беше затворен.")
В този пример, дори ако възникне FileNotFoundError или някаква друга грешка при четенето на файла, кодът във finally блока ще се изпълни и ще се опита да затвори файла (ако е бил успешно отворен).
	Възникване на изключения (raise)
В Python можете и ръчно да предизвикате изключение, използвайки ключовата дума raise. Това може да бъде полезно в ситуации, когато искате да сигнализирате за грешка, която вашата функция или код е открил.

def check_age(age):
    if age < 0:
        raise ValueError("Възрастта не може да бъде отрицателно число!")
    elif age < 18:
        print("Вие сте непълнолетен.")
    else:
        print("Вие сте пълнолетен.")

try:
    user_age = int(input("Въведете вашата възраст: "))
    check_age(user_age)
except ValueError as e:
    print(f"Грешка: {e}")
В тази функция, ако подадената възраст е отрицателна, се предизвиква ValueError с конкретно съобщение за грешка. except ValueError as e улавя това изключение и присвоява обекта на изключението на променливата e, което позволява да се достъпи съобщението за грешка (e).
Обработката на изключения е важна част от писането на стабилен и надежден код на Python. Тя позволява на програмите да се справят грациозно с неочаквани ситуации и да продължат изпълнението си или да завършат по контролиран начин.

Казус 1: Безопасно деление на числа
Напишете функция, която приема две числа като аргументи и връща резултата от тяхното деление. Използвайте try и except блокове, за да обработите случая, когато второто число е нула (ZeroDivisionError). Ако възникне такава грешка, функцията трябва да върне съобщение за грешка вместо да прекратява изпълнението на програмата.
Решение:
def safe_divide(numerator, denominator):
    try:
        result = numerator / denominator
        return result
    except ZeroDivisionError:
        return "Грешка: Деление на нула!"

num1_str = input("Въведете числител: ")
num2_str = input("Въведете знаменател: ")

try:
    num1 = float(num1_str)
    num2 = float(num2_str)
    result = safe_divide(num1, num2)
    print(f"Резултатът от делението е: {result}")
except ValueError:
    print("Грешка: Моля, въведете валидни числа.")

Казус 2: Обработка на грешен файлов път
Напишете програма, която пита потребителя да въведе път до файл и се опитва да отвори файла за четене. Използвайте try и except блокове, за да обработите случая, когато файлът не съществува (FileNotFoundError). Ако файлът бъде успешно отворен, програмата трябва да прочете и изведе първия ред от него, след което да го затвори. Използвайте else блок, за да изпълните четенето и затварянето само ако не е възникнала грешка при отварянето. Използвайте finally блок, за да се уверите, че файлът е затворен, дори ако е възникнала грешка.
Решение:
file_path = input("Въведете пътя до файл: ")
file = None  # Инициализираме file извън try блока

try:
    file = open(file_path, 'r')
except FileNotFoundError:
    print(f"Грешка: Файлът '{file_path}' не беше намерен.")
except Exception as e:
    print(f"Възникна неочаквана грешка: {e}")
else:
    first_line = file.readline().strip()
    print(f"Първият ред от файла е: '{first_line}'")
finally:
    if file:
        file.close()
        print("Файлът беше затворен.")

Казус 3: Валидиране на потребителски вход с възникване на изключение
Напишете функция, която приема потребителски вход за име и проверява дали името съдържа само букви и интервали. Ако името съдържа други символи, функцията трябва да предизвика (raise) потребителско изключение с подходящо съобщение. Напишете и основна част на програмата, която извиква тази функция в try блок и обработва евентуално възникналото изключение в except блок.
Решение:
class InvalidNameError(Exception):
    """Потребителско изключение за невалидно име."""
    pass

def validate_name(name):
    for char in name:
        if not char.isalpha() and char != ' ':
            raise InvalidNameError("Името може да съдържа само букви и интервали.")
    return name

user_input = input("Въведете вашето име: ")

try:
    validated_name = validate_name(user_input)
    print(f"Въведеното име е валидно: {validated_name}")
except InvalidNameError as e:
    print(f"Грешка: {e}")

	Тези казуси илюстрират как да се използват try и except за улавяне и обработка на различни видове вградени изключения (ZeroDivisionError, FileNotFoundError, общо Exception). Казус 2 показва употребата на else и finally блокове за контролиране на потока на изпълнение в зависимост от това дали е възникнала грешка. Казус 3 демонстрира как да се дефинира и предизвика потребителско изключение (InvalidNameError) с помощта на raise, за да се сигнализира за специфични грешки в логиката на програмата.

 
Въпроси:
	Какво е изключение (exception) в Python? Защо е важно да се обработват изключения?
	Обяснете ролята на блоковете try и except при обработката на изключения. Как работи механизмът за улавяне на изключения?
	Може ли да има повече от един except блок след try блок? Защо би било полезно това?
	Каква е ролята на else блока при обработката на изключения? Кога се изпълнява кодът в else блока?
	Каква е ролята на finally блока при обработката на изключения? Кога се изпълнява кодът в finally блока? За какво най-често се използва?
	Как можем ръчно да предизвикаме изключение в Python? В какви ситуации би било полезно да използваме raise?
	Как можем да "уловим" всички видове изключения с един except блок? Защо обикновено не се препоръчва този подход?
	Как можем да достъпим информация за възникнало изключение (например съобщението за грешка)?
Задачи:
	Напишете програма, която приема две числа от потребителя и ги дели. Използвайте try-except блок, за да обработите грешката ZeroDivisionError, ако потребителят въведе 0 като знаменател.
	Напишете програма, която се опитва да отвори файл, чието име е въведено от потребителя. Използвайте try-except блок, за да обработите грешката FileNotFoundError, ако файлът не съществува. Ако файлът бъде отворен успешно, изведете съобщение "Файлът е отворен успешно." и го затворете във finally блок.
	Напишете функция, която приема цяло число като аргумент. Ако числото е по-малко от 0, предизвикайте изключение ValueError с подходящо съобщение. В противен случай върнете квадрата на числото. Извикайте тази функция в try-except блок и обработете евентуалното изключение.
	Напишете програма, която се опитва да преобразува потребителски вход към цяло число. Използвайте try-except ValueError блок, за да обработите случая, когато потребителят въведе невалиден вход. Ако преобразуването е успешно, изведете числото. Добавете else блок, който се изпълнява само ако не е възникнала грешка, и изведете съобщение "Преобразуването беше успешно.".
	Напишете програма, която съдържа списък с числа. Опитайте се да достъпите елемент от списъка по индекс, въведен от потребителя. Използвайте try-except IndexError блок, за да обработите грешката, ако индексът е извън границите на списъка.
	Създайте функция, която приема два списъка с еднаква дължина. Опитайте се да разделите елементите на първия списък на съответните елементи на втория списък. Използвайте try-except ZeroDivisionError блок, за да обработите делението на нула. Съберете резултатите в нов списък и го върнете.
	Напишете програма, която демонстрира използването на try, except и finally блокове. В try блока опитайте да разделите 10 на 0. В except блока изведете съобщение за грешка. Във finally блока изведете съобщение "Край на обработката.".
 
	Четене и писане във файлове
  
Python предоставя вградени функции за работа с файлове, които позволяват на програмите да четат данни от файлове и да записват данни във файлове. Това е съществено за обработка на данни, конфигурация, логиране и много други задачи.
Основни операции с файлове:
	Отваряне на файл (open()): 
Функцията open() се използва за отваряне на файл. Тя приема поне един аргумент - пътя до файла - и връща обект, представляващ файла.
file = open('example.txt', 'r')  # Отваряне на файл за четене ('r' - read)
Вторият аргумент е режимът на отваряне, който указва как ще се използва файлът:
	'r': Четене (грешка, ако файлът не съществува).
	'w': Писане (създава файл, ако не съществува, или презаписва съществуващ).
	'a': Добавяне (създава файл, ако не съществува, или добавя към края на съществуващ).
	'b': Бинарен режим (използва се с други режими, напр. 'rb', 'wb').
	'+': Режим за четене и писане (използва се с други режими, напр. 'r+', 'w+').
Препоръчително е винаги да указвате режима при отваряне на файл.
	Четене от файл: 
След като файлът е отворен за четене, можете да използвате различни методи за четене на съдържанието му:
	.read(): Прочита цялото съдържание на файла като един низ.
	.readline(): Прочита един ред от файла (включително знака за нов ред \n в края).
	.readlines(): Прочита всички редове на файла и ги връща като списък от низове.
with open('example.txt', 'r') as file:
    content = file.read()
    print("Цялото съдържание:\n", content)

with open('example.txt', 'r') as file:
    line1 = file.readline()
    line2 = file.readline()
    print("\nПърви ред:", line1)
    print("Втори ред:", line2)

with open('example.txt', 'r') as file:
    lines = file.readlines()
    print("\nВсички редове като списък:\n", lines)

	Писане във файл: 
Ако файлът е отворен в режим за писане ('w') или добавяне ('a'), можете да записвате данни в него с метода .write():
with open('output.txt', 'w') as file:
    file.write("Това е първият ред.\n")
    file.write("Това е вторият ред.\n")

with open('append.txt', 'a') as file:
    file.write("Добавен ред към края.\n")

	Затваряне на файл (close()): 
След като приключите работа с файла, е важно да го затворите, за да освободите системните ресурси и да се гарантира, че всички записани данни са запазени.
file = open('example.txt', 'r')
# ... работа с файла ...
file.close()
	По-добър начин: with statement: 
Препоръчително е да използвате конструкцията with open(...) as file:. Тя автоматично затваря файла, дори ако възникне грешка по време на работа с него.
	Пример за четене и обработка на данни от файл:
Предполагаме, че имаме файл data.txt, където всеки ред съдържа име и възраст, разделени със запетая:	
Alice,30
Bob,25
Charlie,35

Можем да прочетем този файл и да изведем информацията:
with open('data.txt', 'r') as file:
    for line in file:
        name, age_str = line.strip().split(',')
        age = int(age_str)
        print(f"{name} е на {age} години.")

	Бинарното четене на файлове
За разлика от текстовите файлове, които съдържат последователност от символи, кодирани по определен начин (например UTF-8), бинарните файлове съдържат сурови байтове информация. Те не се опитват да интерпретират тези байтове като текст.
Използваме бинарно четене (и писане) в следните основни случаи:
	Работа с нетекстови файлове:
	Изображения (JPEG, PNG, GIF и др.): Тези файлове съдържат информация за пикселите, цветовете и метаданните в бинарен формат. Опитът да ги прочетете като текст ще доведе до неразбираеми символи и евентуално грешки.
	Аудио файлове (MP3, WAV, AAC и др.): Съдържат кодирани звукови данни в бинарен формат.
	Видео файлове (MP4, AVI, MKV и др.): Комбинация от аудио и видео потоци, кодирани в бинарен формат.
	Изпълними файлове (.exe, .dll и др.): Съдържат инструкции за процесора в бинарен вид.
	Компресирани файлове (.zip, .gz, .bz2 и др.): Съдържат компресирани данни, които трябва да се четат и декомпресират като байтове.
	Сериализирани обекти (използвайки pickle, marshal): Когато Python обекти (като списъци, речници, класове) се записват във файл за по-късно използване, те често се сериализират в бинарен формат. Това запазва структурата и типа на обектите.
	Файлове на бази данни: Много файлове на бази данни имат специфичен бинарен формат за съхранение на данните.
	Когато се нуждаем от точен контрол върху байтовете:
	В някои задачи от ниско ниво, като работа с мрежови протоколи или хардуерни интерфейси, може да се наложи директно четене и манипулиране на байтове.
	Как се извършва бинарно четене:
За да прочетете файл в бинарен режим, трябва да отворите го с режима 'rb' (read binary). Методите за четене ще връщат bytes обекти, а не низове (str).
with open('image.jpg', 'rb') as binary_file:
    binary_data = binary_file.read()
    # binary_data е обект от тип bytes
    print(f"Прочетени {len(binary_data)} байта.")

with open('data.pkl', 'rb') as pickle_file:
    import pickle
    loaded_data = pickle.load(pickle_file)
    print("Десериализирани данни:", loaded_data)

Важно: Когато работите с бинарни файлове, трябва да знаете структурата на файла, за да можете правилно да интерпретирате прочетените байтове. За много бинарни формати съществуват специфични библиотеки, които помагат при парсването и обработката на данните (например, PIL за изображения, wave за аудио, struct за работа с бинарни структури).
 
въпроси и задачи:
	Каква е основната разлика между режимите за отваряне на файл 'r', 'w' и 'a' в Python? Обяснете какво се случва, ако отворите съществуващ файл в режим 'w'.
	Напишете код, който отваря текстов файл с име my_file.txt в режим за четене и извежда съдържанието му на конзолата. Представете си, че файлът съдържа няколко реда текст.
	Как се чете един ред от файл в Python? Как се четат всички редове наведнъж?
	Напишете код, който създава нов текстов файл с име new_file.txt и записва в него следния текст: 
	Това е първият ред.
	Това е вторият ред.
	Как се затваря файл след като е бил отворен в Python? Защо е важно да затваряте файловете?
	Какво представлява контекстният мениджър with при работа с файлове в Python? Какви са предимствата от използването му? Пренапишете кода от задача 2 и 4, използвайки with.
Средно ниво на трудност:
	Напишете функция, която приема име на файл като аргумент и връща броя на редовете в този файл.
	Създайте програма, която чете текстов файл и записва съдържанието му в друг файл, като преобразува всички букви в горния регистър.
	Напишете код, който чете файл с числа, разделени със запетаи, и изчислява тяхната сума.
	Създайте програма, която пита потребителя да въведе няколко имена и ги записва във файл, като всяко име е на нов ред.
	Обяснете разликата между методите read() и readlines() при четене на файлове. Кога бихте използвали всеки от тях?
	Как можете да добавите нов текст към съществуващ файл, без да изтривате старото съдържание? Напишете примерен код.
По-високо ниво на трудност:
	Напишете функция, която приема име на файл и дума като аргументи и връща броя на срещанията на тази дума в файла (без да се case-sensitive).
	Създайте програма, която чете CSV файл (Comma Separated Values) и извежда данните в табличен вид на конзолата. Можете да използвате вградения модул csv на Python.
	Напишете код, който чете голям текстов файл (който може да не се побере в паметта) и преброява честотата на всяка дума в него. Резултатът трябва да бъде записан в друг файл, сортиран по честота (от най-честата към най-рядката).
	Как се работи с двоични файлове в Python? Напишете пример за четене и запис на прости двоични данни (например, списък от байтове).
	Създайте програма, която архивира (zip) дадена директория, включително всички нейни поддиректории и файлове, и записва архива в нов файл. Можете да използвате модула zipfile.
	Напишете функция, която приема име на текстов файл и премахва всички празни редове от него, като записва промените обратно в същия файл.
Тези въпроси и задачи покриват основните и по-напреднали аспекти на работата с файлове в Python. Можеш да ги използваш за обучение, упражнение или оценка на знанията по тази тема. Успех!
Въпроси и Задачи:
	Каква е основната разлика между режимите за отваряне на файл 'r', 'w' и 'a' в Python? Обяснете какво се случва, ако отворите съществуващ файл в режим 'w'.
	Напишете код, който отваря текстов файл с име my_file.txt в режим за четене и извежда съдържанието му на конзолата. Представете си, че файлът съдържа няколко реда текст.
	Как се чете един ред от файл в Python? Как се четат всички редове наведнъж?
	Напишете код, който създава нов текстов файл с име new_file.txt и записва в него следния текст: 
	Това е първият ред.
	Това е вторият ред.
	Как се затваря файл след като е бил отворен в Python? Защо е важно да затваряте файловете?
	Какво представлява контекстният мениджър with при работа с файлове в Python? Какви са предимствата от използването му? Пренапишете кода от задача 2 и 4, използвайки with.
Средно ниво на трудност:
	Напишете функция, която приема име на файл като аргумент и връща броя на редовете в този файл.
	Създайте програма, която чете текстов файл и записва съдържанието му в друг файл, като преобразува всички букви в горния регистър.
	Напишете код, който чете файл с числа, разделени със запетаи, и изчислява тяхната сума.
	Създайте програма, която пита потребителя да въведе няколко имена и ги записва във файл, като всяко име е на нов ред.
	Обяснете разликата между методите read() и readlines() при четене на файлове. Кога бихте използвали всеки от тях?
	Как можете да добавите нов текст към съществуващ файл, без да изтривате старото съдържание? Напишете примерен код.
По-високо ниво на трудност:
	Напишете функция, която приема име на файл и дума като аргументи и връща броя на срещанията на тази дума в файла (без да се case-sensitive).
	Създайте програма, която чете CSV файл (Comma Separated Values) и извежда данните в табличен вид на конзолата. Можете да използвате вградения модул csv на Python.
	Напишете код, който чете голям текстов файл (който може да не се побере в паметта) и преброява честотата на всяка дума в него. Резултатът трябва да бъде записан в друг файл, сортиран по честота (от най-честата към най-рядката).
	Как се работи с двоични файлове в Python? Напишете пример за четене и запис на прости двоични данни (например, списък от байтове).
	Създайте програма, която архивира (zip) дадена директория, включително всички нейни поддиректории и файлове, и записва архива в нов файл. Можете да използвате модула zipfile.
	Напишете функция, която приема име на текстов файл и премахва всички празни редове от него, като записва промените обратно в същия файл.
	Работа с модули и пакети
 
Една от силните страни на Python е неговата богата стандартна библиотека и голямата екосистема от външни библиотеки и пакети, които могат значително да разширят функционалността на вашите програми. Модулите и пакетите са механизми за организиране и повторно използване на код в Python.
	Разлика между модули и пакети
	Модули
Модулът в Python е просто файл с разширение .py, който съдържа Python код - дефиниции на функции, класове, променливи и др. Модулите позволяват да разделите програмата си на по-малки, логически обособени части, което улеснява разбирането, поддръжката и повторното използване на кода.
	Импортиране на модули (import)
За да използвате код от даден модул във вашата програма, трябва първо да го импортирате с помощта на ключовата дума import.
import math

# Използване на функции и константи от модула math
print(math.sqrt(16))      # Извежда: 4.0
print(math.pi)            # Извежда: 3.141592653589793
print(math.sin(math.radians(30))) # Извежда: 0.49999999999999994                  # Извежда: <class 'str'>
Когато импортирате модул по този начин, вие получавате достъп до всички дефиниции в него, като използвате точкова нотация (име_на_модул.име_на_дефиниция).
	Импортиране на конкретни имена от модул (from ... import ...)
Ако искате да използвате само определени функции или класове от модул, можете да ги импортирате директно, без да е необходимо да използвате името на модула като префикс.
from datetime import date, timedelta

today = date.today()
print(today)              # Извежда текущата дата

one_week_ago = today - timedelta(weeks=1)
print(one_week_ago)       # Извежда датата отпреди една седмица

Можете да импортирате всички имена от модул (не се препоръчва често, тъй като може да доведе до конфликти на имена) с помощта на звездичка (*):

from math import *
print(sqrt(25))

	Псевдоними на модули и импортирани имена (as)
Можете да дадете псевдоним (алтернативно име) на импортиран модул или конкретно име, което може да бъде полезно, ако името е дълго или ако има конфликт на имена.
import pandas as pd

data = {'col1': [1, 2], 'col2': [3, 4]}
df = pd.DataFrame(data)
print(df)

from math import sqrt as square_root

print(square_root(9))     # Извежда: 3.0

	Пакети
Пакетът е начин за структуриране на Python модули чрез използване на "точкови имена на модули". Концептуално, пакетите са директории във файловата система, а модулите са файлове с разширение .py в тези директории.
За да бъде една директория разпозната като пакет от Python, тя трябва да съдържа специален файл с име __init__.py. Този файл може да бъде празен или да съдържа код за инициализация на пакета или да дефинира кои модули да бъдат импортирани, когато се импортира самият пакет.
Представете си следната структура на директории:
my_project/
├── my_package/
│   ├── __init__.py
│   ├── module1.py
│   └── module2.py
└── main.py
В този случай my_package е пакет, съдържащ два модула: module1.py и module2.py.
	Импортиране на модули от пакет
Можете да импортирате модули от пакет, използвайки точкова нотация:
# main.py
import my_package.module1
import my_package.module2

my_package.module1.some_function()
result = my_package.module2.some_variable

Или можете да използвате from ... import ...:
# main.py
from my_package import module1, module2

module1.another_function()
value = module2.another_variable

from my_package.module1 import specific_function

specific_function(10)

	Съдържание на __init__.py
Файлът __init__.py може да бъде празен, но също така може да съдържа код за инициализация на пакета. Често се използва за дефиниране на кои подмодули да бъдат импортирани, когато се импортира самият пакет. Например, в my_package/__init__.py можете да имате:
# my_package/__init__.py
from . import module1
from . import module2
След това в main.py можете да импортирате пакета и да имате достъп до модулите директно:
# main.py
import my_package

my_package.module1.yet_another_function()
my_package.module2.yet_another_variable
Също така, __init__.py може да дефинира кои имена да бъдат импортирани, когато се използва from my_package import * (не се препоръчва често).
	Импортиране (import, import as, from ... import ...)
Както вече споменахме, Python предлага няколко начина за импортиране на модули и съдържание от тях:
	import име_на_модул:
Този начин импортира целия модул. След импортирането, трябва да използвате името на модула като префикс, за да достъпите неговите функции, класове и променливи.
import math

print(math.sqrt(25))
print(math.pi)
	Предимства: Ясно е откъде идва всяко име (модулът е префикс). Намалява риска от конфликти на имена (ако две различни библиотеки имат функции с едно и също име).
	Недостатъци: Може да бъде по-дълго за писане, ако често използвате имена от модула.
	import име_на_модул as псевдоним:
Този начин импортира целия модул, но му дава по-кратък или по-удобен псевдоним. Това е полезно за дълги имена на модули или за конвенционални псевдоними (например pd за pandas, np за numpy).
import datetime as dt

today = dt.date.today()
print(today)
	Предимства: По-кратък и по-лесен за писане код при често използване на имена от модула. Може да помогне за избягване на конфликти на имена, ако псевдонимът е уникален.
	Недостатъци: Все още трябва да използвате псевдонима като префикс.
	from име_на_модул import име1, име2, ...:
Този начин импортира само конкретно посочените имена (функции, класове, променливи) директно в текущото пространство от имена. След импортирането можете да ги използвате без префикса на модула.
from os import path, getcwd

current_directory = getcwd()
print(f"Текущата директория е: {current_directory}")

file_exists = path.exists("my_file.txt")
print(f"Файлът съществува: {file_exists}")

	Предимства: По-кратък и по-лесен за писане код, тъй като не е необходим префикс.
	Недостатъци: Може да доведе до конфликти на имена, ако импортираните имена съвпадат с вече съществуващи имена в текущото пространство от имена или с имена от други импортирани модули. Трудно е да се разбере откъде идва дадено име, ако са импортирани много имена от различни модули.

	from име_на_модул import име as псевдоним:
Този начин комбинира импортирането на конкретно име с даването му на псевдоним. Това е полезно за избягване на конфликти на имена или за по-кратко име.
from math import sqrt as корен_квадратен

result = корен_квадратен(100)
print(result)
	Предимства: Позволява използването на по-кратко или по-ясно име за конкретно импортирана функция или клас. Помага за избягване на конфликти на имена.
	Недостатъци: Трябва да следите псевдонимите.
	from име_на_модул import * (избягвайте, ако е възможно):
Този начин импортира всички имена от модула директно в текущото пространство от имена.
from math import *
print(sin(radians(90)))
print(cos(0))
	Предимства: Най-кратък начин за използване на много имена от модул.
	Недостатъци: Силно се препоръчва да се избягва, защото може да доведе до сериозни конфликти на имена, които могат да бъдат трудни за откриване и отстраняване. Също така, прави кода по-труден за четене и разбиране, тъй като не е ясно откъде идват използваните имена.
	Най-добри практики при импортиране:
	Обикновено е по-добре да импортирате целия модул (import име_на_модул) или конкретни имена (from име_на_модул import име1, име2).
	Използвайте псевдоними (as) разумно, за да подобрите четимостта или да избегнете конфликти.
	Избягвайте използването на from име_на_модул import *, освен в много специфични случаи, когато сте сигурни, че няма да има конфликти на имена (например в кратки скриптове или при работа с добре познати библиотеки, където конфликтите са малко вероятни).
	Подреждайте import изразите в началото на файла, обикновено в следния ред: 
	Стандартни библиотеки на Python
	Външни библиотеки (инсталирани с pip)
	Ваши собствени модули
Разбирането на различните начини за импортиране ви дава гъвкавост при работата с модули и пакети в Python, но е важно да избирате подхода разумно, за да поддържате кода си четим и лесен за разбиране.

	Инсталиране на пакети с pip (pip install math , pip install os)

	Инсталиране на пакети с pip (pip install)

pip е стандартният пакетен мениджър за Python. Той ви позволява лесно да инсталирате и управлявате пакети, които не са част от стандартната библиотека на Python. Когато искате да използвате външна библиотека или пакет във вашия проект, най-често ще използвате pip за да го инсталирате.
	Основна команда за инсталиране:
За да инсталирате пакет, отворете терминал (на macOS и Linux) или команден прозорец (на Windows) и използвайте командата:
pip install име_на_пакет
Важни неща, които трябва да знаете за инсталирането на пакети с pip:
	Свързване с интернет: За да инсталира пакети, pip трябва да има достъп до интернет, за да изтегли пакета от хранилището PyPI (Python Package Index) - най-голямото хранилище за Python софтуер.
	Python среда: Уверете се, че pip командата, която изпълнявате, е свързана с Python инсталацията и виртуалната среда (ако използвате такава), за която искате да инсталирате пакета. Ако имате няколко инсталации на Python, може да се наложи да използвате pip3 вместо pip или да активирате вашата виртуална среда преди да инсталирате пакета.
	PyPI (Python Package Index): По подразбиране, pip търси пакети в PyPI. Когато изпълните pip install име_на_пакет, pip се свързва с PyPI, търси пакета с това име и ако го намери, го изтегля и инсталира във вашата Python среда.
	Процес на инсталация: По време на инсталацията, pip ще покаже информация за процеса, включително изтеглянето на пакета и неговите зависимости, както и стъпките по инсталирането. Ако инсталацията е успешна, ще видите съобщение, че пакетът е инсталиран успешно.
	Пример за успешна инсталация на пакета requests:
pip install requests
Collecting requests
  Downloading requests-2.28.1-py3-none-any.whl (62 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 62.7/62.7 kB 1.8 MB/s eta 0:00:00
Collecting urllib3<1.27,>=1.21.1
  Downloading urllib3-1.26.14-py2.py3-none-any.whl (140 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 140.6/140.6 kB 4.0 MB/s eta 0:00:00
Collecting idna<4,>=2.5
  Downloading idna-3.4-py3-none-any.whl (61 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 61.5/61.5 kB 3.4 MB/s eta 0:00:00
Collecting charset-normalizer<3,>=2
  Downloading charset_normalizer-2.1.1-py3-none-any.whl (39 kB)
     ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 39.2/39.2 kB 2.1 MB/s eta 0:00:00
Installing collected packages: urllib3, idna, charset-normalizer, requests
Successfully installed charset-normalizer-2.1.1 idna-3.4 requests-2.28.1 urllib3-1.26.14
	Грешки при инсталация: Възможно е да възникнат грешки по време на инсталацията поради различни причини (например, липса на интернет връзка, проблеми с PyPI, конфликти с други пакети, липсващи системни зависимости). Ако инсталацията не е успешна, pip ще покаже съобщение за грешка, което може да ви помогне да диагностицирате проблема.
	  Пакет math: В примера pip install math, трябва да се отбележи, че модулът math е част от стандартната библиотека на Python. Това означава, че той вече е инсталиран с Python и не е необходимо да го инсталирате с pip. Опитът да го инсталирате с pip може да доведе до съобщение, че изискването вече е изпълнено (Requirement already satisfied).
pip install math
Requirement already satisfied: math in /usr/lib/python3.10 (3.10.6)
В обобщение, pip install име_на_пакет е основната команда за инсталиране на външни Python пакети от PyPI. Уверете се, че използвате правилната pip команда за вашата Python среда и имате интернет връзка. За стандартните библиотеки като math, не е необходимо да използвате pip install.

	Модулът math
Той е част от стандартната библиотека и предоставя голям набор от математически функции и константи. Тъй като е част от стандартната библиотека, не е необходимо да го инсталирате с pip - той е наличен веднага след инсталиране на Python.
За да използвате функциите и константите от модула math, първо трябва да го импортирате във вашия скрипт:

import math

След това можете да достъпвате различните елементи на модула, използвайки точкова нотация (math.име_на_функция или math.име_на_константа).

	Константи, дефинирани в модула math:

	math.pi: Математическата константа π (пи), приблизително равна на 3.14159.
print(math.pi)  # Извежда: 3.141592653589793

	math.e: Математическата константа e (основата на натуралния логаритъм), приблизително равна на 2.71828.
print(math.e)   # Извежда: 2.718281828459045

	math.tau: Математическата константа τ (тау), равна на 2π, приблизително равна на 6.28318. Някои математици и програмисти предпочитат тау пред пи.
print(math.tau) # Извежда: 6.283185307179586


	math.inf: Плаваща запетая, представляваща положителна безкрайност
print(math.inf) # Извежда: inf

	math.nan: Плаваща запетая, представляваща "не е число" (Not a Number).
print(math.nan) # Извежда: nan

	Функции, дефинирани в модула math:
Модулът math предоставя широк набор от математически функции, които могат да бъдат групирани в няколко категории:
	Тригонометрични функции:
	math.sin(x): Връща синус от x (в радиани).
	math.cos(x): Връща косинус от x (в радиани).
	math.tan(x): Връща тангенс от x (в радиани).
	math.asin(x): Връща арксинус от x (в радиани).
	math.acos(x): Връща аркускосинус от x (в радиани).
	math.atan(x): Връща арктангенс от x (в радиани).
	math.degrees(x): Преобразува ъгъл от радиани в градуси.
	math.radians(x): Преобразува ъгъл от градуси в радиани.
angle_degrees = 30
angle_radians = math.radians(angle_degrees)
print(f"Синус от {angle_degrees} градуса: {math.sin(angle_radians)}")
	Хиперболични функции:
	math.sinh(x): Връща хиперболичен синус от x.
	math.cosh(x): Връща хиперболичен косинус от x.
	math.tanh(x): Връща хиперболичен тангенс от x.
	math.asinh(x): Връща обратен хиперболичен синус от x.
	math.acosh(x): Връща обратен хиперболичен косинус от x.
	math.atanh(x): Връща обратен хиперболичен тангенс от x.
	Експоненциални и логаритмични функции:
	math.exp(x): Връща ex.
	math.log(x[, base]): Връща логаритъм на x по основа base (по подразбиране натурален логаритъм).
	math.log10(x): Връща логаритъм на x по основа 10.
	math.pow(x, y): Връща xy. (Операторът ** също върши тази работа).
	math.sqrt(x): Връща квадратния корен от x.
	Функции за закръгляне и работа с числа:
	  math.ceil(x): Връща най-малкото цяло число, по-голямо или равно на x.
	  math.floor(x): Връща най-голямото цяло число, по-малко или равно на x.
	  math.trunc(x): Връща x, отрязано до цяло число (премахва дробната част).
	  math.fabs(x): Връща абсолютната стойност на x.
	  math.fmod(x, y): Връща остатъка от делението на x на y. (Операторът % също върши подобна работа, но math.fmod може да даде различен резултат при отрицателни числа).
	  math.factorial(x): Връща факториел на цялото число x.
	  math.gcd(a, b): Връща най-големия общ делител на целите числа a и b.
	  math.isfinite(x): Проверява дали x е крайно число (не е безкрайност или NaN).
	  math.isinf(x): Проверява дали x е положителна или отрицателна безкрайност.
	  math.isnan(x): Проверява дали x е NaN (Not a Number).

number = 3.7
print(f"ceil({number}): {math.ceil(number)}")
print(f"floor({number}): {math.floor(number)}")
print(f"trunc({number}): {math.trunc(number)}")
print(f"abs(-5): {math.fabs(-5)}")
print(f"gcd(12, 18): {math.gcd(12, 18)}")
	
	Това е само част от функционалността, която предлага модулът math. Той е изключително полезен за всякакви математически изчисления във вашите Python програми. Не забравяйте да импортирате модула, преди да използвате неговите функции и константи.

	модулът datetime
Той е част от стандартната библиотека и предоставя класове за работа с дати и часове. С помощта на този модул можете да създавате, манипулирате и форматирате дати и часове по различни начини.
За да използвате класовете и функциите от модула datetime, първо трябва да го импортирате:
import datetime
Модулът datetime съдържа няколко основни класа:
	datetime.date: Представлява дата (година, месец, ден).
	datetime.time: Представлява време (час, минута, секунда, микросекунда).
	datetime.datetime: Комбинация от дата и време.
	datetime.timedelta: Представлява разлика във времето (продължителност).
	datetime.timezone: Представлява часова зона (абстрактен базов клас).
	datetime.tzinfo: Информация за часови зони (абстрактен базов клас).
Нека разгледаме по-подробно някои от тези класове и техните основни методи и свойства:
	Клас datetime.date:
	Създаване на date обекти:
	datetime.date(year, month, day): Създава date обект с дадена година, месец и ден.
	datetime.date.today(): Връща текущата дата.
	date_object.replace(year=..., month=..., day=...): Връща нов date обект със заменени указани стойности.
	datetime.date.fromtimestamp(timestamp): Създава date обект от POSIX timestamp (брой секунди от 01.01.1970 UTC).
	datetime.date.fromisoformat(date_string): Създава date обект от низ във формат 'YYYY-MM-DD'.

today = datetime.date.today()
print(f"Днес е: {today}")  # Извежда: Днес е: 2025-04-29

specific_date = datetime.date(2023, 10, 26)
print(f"Конкретна дата: {specific_date}")  # Извежда: Конкретна дата: 2023-10-26

next_day = today.replace(day=today.day + 1)
print(f"Утре ще бъде: {next_day}")  # Извежда: Утре ще бъде: 2025-04-30

timestamp = 1672531200  # 01.01.2023 00:00:00 UTC
date_from_timestamp = datetime.date.fromtimestamp(timestamp)
print(f"Дата от timestamp: {date_from_timestamp}")  # Извежда: Дата от timestamp: 2023-01-01

iso_date = datetime.date.fromisoformat('2024-01-15')
print(f"Дата от ISO формат: {iso_date}") # Извежда: Дата от ISO формат: 2024-01-15

	Свойства на date обекти:
	date_object.year
	date_object.month
	date_object.day
print(f"Година: {today.year}, Месец: {today.month}, Ден: {today.day}")
# Извежда: Година: 2025, Месец: 4, Ден: 29

	Методи на date обекти:
	date_object.strftime(format): Форматира датата като низ според зададен формат.
	date_object.isoformat(): Връща датата като низ във формат 'YYYY-MM-DD'.
formatted_date = today.strftime("%d.%m.%Y")
print(f"Форматирана дата: {formatted_date}")  # Извежда: Форматирана дата: 29.04.2025

iso_format = today.isoformat()
print(f"ISO формат: {iso_format}")  # Извежда: ISO формат: 2025-04-29

	Клас datetime.time:
	Създаване на time обекти:
	datetime.time(hour=0, minute=0, second=0, microsecond=0, tzinfo=None): Създава time обект с дадени час, минута, секунда и микросекунда.
	time_object.replace(hour=..., minute=..., second=..., microsecond=..., tzinfo=...): Връща нов time обект със заменени указани стойности.
	datetime.time.fromisoformat(time_string): Създава time обект от низ във формат 'HH:MM:SS.ffffff' или 'HH:MM:SS'.
specific_time = datetime.time(14, 30, 45)
print(f"Конкретно време: {specific_time}")  # Извежда: Конкретно време: 14:30:45

another_time = datetime.time(hour=9, minute=0)
print(f"Друго време: {another_time}") # Извежда: Друго време: 09:00:00

later_time = specific_time.replace(hour=15)
print(f"По-късно време: {later_time}") # Извежда: По-късно време: 15:30:45

iso_time = datetime.time.fromisoformat('21:05:00')
print(f"Време от ISO формат: {iso_time}") # Извежда: Време от ISO формат: 21:05:00

	Свойства на time обекти:
	time_object.hour
	time_object.minute
	time_object.second
	time_object.microsecond
	time_object.tzinfo
print(f"Час: {specific_time.hour}, Минута: {specific_time.minute}, Секунда: {specific_time.second}")
# Извежда: Час: 14, Минута: 30, Секунда: 45
	Методи на time обекти:
	time_object.strftime(format): Форматира времето като низ според зададен формат.
	time_object.isoformat(): Връща времето като низ във формат 'HH:MM:SS.ffffff' или 'HH:MM:SS'.
formatted_time = specific_time.strftime("%H:%M")
print(f"Форматирано време: {formatted_time}")  # Извежда: Форматирано време: 14:30

iso_format_time = specific_time.isoformat()
print(f"ISO формат време: {iso_format_time}") # Извежда: ISO формат време: 14:30:45

	Клас datetime.datetime:
	Създаване на datetime обекти:
	datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None): Създава datetime обект с дадена дата и време.
	datetime.datetime.now(tz=None): Връща текущата дата и време (по избор с информация за часова зона).
	datetime.datetime.utcnow(): Връща текущата UTC дата и време (без информация за часова зона).
	datetime.datetime.combine(date_object, time_object, tzinfo=None): Комбинира date и time обекти.
	datetime.datetime.strptime(date_string, format): Създава datetime обект от низ според зададен формат.
	datetime.datetime.fromisoformat(datetime_string): Създава datetime обект от низ във формат 'YYYY-MM-DDTHH:MM:SS.ffffff' или 'YYYY-MM-DD HH:MM:SS'.
now = datetime.datetime.now()
print(f"Сега е: {now}")  # Извежда: Сега е: 2025-04-29 13:01:00.123456

specific_datetime = datetime.datetime(2024, 5, 10, 10, 0, 0)
print(f"Конкретна дата и час: {specific_datetime}") # Извежда: Конкретна дата и час: 2024-05-10 10:00:00

date_obj = datetime.date(2025, 1, 1)
time_obj = datetime.time(12, 0, 0)
combined_datetime = datetime.datetime.combine(date_obj, time_obj)
print(f"Комбинирана дата и час: {combined_datetime}") # Извежда: Комбинирана дата и час: 2025-01-01 12:00:00

datetime_from_str = datetime.datetime.strptime("2023-11-15 08:30:00", "%Y-%m-%d %H:%M:%S")
print(f"Дата и час от низ: {datetime_from_str}") # Извежда: Дата и час от низ: 2023-11-15 08:30:00

iso_datetime = datetime.datetime.fromisoformat('2024-07-20T15:45:30')
print(f"Дата и час от ISO формат: {iso_datetime}") # Извежда: Дата и час от ISO формат: 2024-07-20 15:45:30

	Свойства на datetime обекти:
	datetime_object.year, datetime_object.month, datetime_object.day
	datetime_object.hour, datetime_object.minute, datetime_object.second, datetime_object.microsecond 
	datetime_object.date(): Връща date обект.
	datetime_object.time(): Връща time обект.
	datetime_object.tzinfo
	Методи на datetime обекти:
	datetime_object.strftime(format): Форматира датата и времето като низ.
	datetime_object.isoformat(sep='T', timespec='auto'): Връща дата и час като низ в ISO формат.
formatted_now = now.strftime("%d/%m/%Y %H:%M:%S")
print(f"Форматирано сега: {formatted_now}") # Извежда: Форматирано сега: 29/04/2025 13:01:00

iso_format_now = now.isoformat()
print(f"ISO формат сега: {iso_format_now}") # Извежда: ISO формат сега: 2025-04-29T13:01:00.123456

	Клас datetime.timedelta:
	Представлява продължителност или разлика между две дати или времена.
	Може да бъде създаден с параметри days, seconds, microseconds, milliseconds, minutes, hours, weeks.
delta_one_day = datetime.timedelta(days=1)
print(f"Един ден: {delta_one_day}") # Извежда: Един ден: 1 day, 0:00:00

delta_one_hour = datetime.timedelta(hours=1.5)
print(f"Полвин час: {delta_one_hour}") # Извежда: Полвин час: 1 day, 12:00:00

future_date = today + delta_one_day
print(f"Утре: {future_date}") # Извежда: Утре: 2025-04-30

time_difference = now - datetime.datetime(2025, 4, 29, 10, 0, 0)
print(f"Разлика във времето: {time_difference}") # Извежда: Разлика във времето: 3:01:00.123456

	Форматиране с strftime() и strptime():
Модулът datetime използва специални кодове за форматиране на дати и часове като низове и за парсване на низове към datetime обекти. Някои често използвани кодове включват:
	%Y: Година с четири цифри (например 2023)
	%m: Месец като число (01-12)
	%d: Ден от месеца (01-31)
	%H: Час (24-часов формат, 00-23)
	%M: Минути (00-59)
	%S: Секунди (00-59)
	%f: Микросекунди (000000-999999)
	%a: Съкратено име на деня от седмицата (например Пон)
	%A: Пълно име на деня от седмицата (например Понеделник)
	%b: Съкратено име на месеца (например Яну)
	%B: Пълно име на месеца (например Януари)
Пълният списък с кодове може да бъде намерен в документацията на Python за модула datetime. Модулът datetime е изключително мощен и гъвкав за работа с дати и часове в Python. Той е основен инструмент за много приложения, които изискват обработка на времева информация.


	Модулът os
Той е част от стандартната библиотека и предоставя начин за взаимодействие с операционната система, на която работи Python. Чрез модула os можете да извършвате различни операции, свързани с файловата система, процесите, променливите на средата и други системни функции.
За да използвате функциите от модула os, първо трябва да го импортирате:
import os
Ето някои от най-често използваните функции и подмодули на модула os:
	Работа с файловата система:
	Пътища (Paths):
 Модулът os.path предоставя функции за манипулиране на пътища към файлове и директории по начин, който е съвместим с операционната система. Някои полезни функции включват:
	os.path.abspath(path): Връща абсолютния път до файла или директорията.
	os.path.basename(path): Връща последната част от пътя (името на файла или директорията).
	os.path.dirname(path): Връща частта от пътя, която е директорията.
	os.path.join(path1, path2, ...): Съединява няколко пътя по начин, съвместим с операционната система.
	os.path.exists(path): Проверява дали пътят съществува.
	os.path.isfile(path): Проверява дали пътят е файл.
	os.path.isdir(path): Проверява дали пътят е директория.
	os.path.splitext(path): Разделя пътя на име на файл и разширение.
file_path = "my_folder/my_file.txt"
print(f"Абсолютен път: {os.path.abspath(file_path)}")
print(f"Базово име: {os.path.basename(file_path)}")
print(f"Име на директория: {os.path.dirname(file_path)}")
new_path = os.path.join("home", "user", "documents", "report.pdf")
print(f"Съединен път: {new_path}")
print(f"Съществува ли '{file_path}': {os.path.exists(file_path)}")

	Създаване и премахване на директории:
	os.mkdir(path): Създава нова директория.
	os.makedirs(path): Създава всички необходими междинни директории.
	os.rmdir(path): Премахва празна директория.
	os.removedirs(path): Премахва директории рекурсивно, ако са празни.
os.mkdir("new_directory")
os.makedirs("nested/directory/structure")
os.rmdir("new_directory")
os.removedirs("nested/directory/structure")

	Работа с файлове (някои основни операции):
	os.rename(old_path, new_path): Преименува файл или директория.
	os.remove(path): Изтрива файл.
os.rename("old_file.txt", "new_file.txt")
os.remove("unneeded_file.txt")

	Списък на съдържанието на директория:
	os.listdir(path='.'): Връща списък с имената на файловете и директориите в дадена директория (по подразбиране текущата)
current_content = os.listdir()
print(f"Съдържание на текущата директория: {current_content}")

Пример:
	Сравнение на съдържанието на две папки и намиране на файловете, които са уникални за всяка от тях.
import os

def find_unique_files(folder1, folder2):
    # Получаване на списъци с файловете в двете папки
    files_in_folder1 = set(os.listdir(folder1))
    files_in_folder2 = set(os.listdir(folder2))

    # Намиране на уникалните файлове
    unique_to_folder1 = files_in_folder1 - files_in_folder2
    unique_to_folder2 = files_in_folder2 - files_in_folder1

    return unique_to_folder1, unique_to_folder2


folder1 = input("Въведете пътя до първата папка: ").strip()
folder2 = input("Въведете пътя до втората папка: ").strip()

if not os.path.isdir(folder1):
   print(f"Папката {folder1} не съществува или не е валидна.")
   exit(1)

if not os.path.isdir(folder2):
   print(f"Папката {folder2} не съществува или не е валидна.")
   exit(1)

unique_to_folder1, unique_to_folder2 = find_unique_files(folder1, folder2)

print("\nФайлове уникални за първата папка:")
for file in unique_to_folder1:
  print(file)

print("\nФайлове уникални за втората папка:")
for file in unique_to_folder2:
  print(file)
Скриптът сравнява две папки и извежда списъци с:
	файловете, които се намират само в първата папка;
	файловете, които се намират само във втората папка.

	Промяна на текущата работна директория:
	os.getcwd(): Връща текущата работна директория.
	os.chdir(path): Променя текущата работна директория на path.
print(f"Текуща работна директория: {os.getcwd()}")
os.chdir("/tmp")
print(f"Нова работна директория: {os.getcwd()}")
os.chdir("...") # Връщане нагоре

	Работа с процеси:
	os.system(command): Изпълнява системна команда (като низ). Връща статус кода на командата.
	os.startfile(path) (само за Windows): Стартира файл с асоциираното приложение.
	Модулът subprocess предоставя по-гъвкави инструменти за управление на подпроцеси.
result = os.system("ls -l") # На Linux/macOS
result = os.system("dir")    # На Windows
print(f"Статус код на командата: {result}")
os.startfile("my_document.pdf") # На Windows

	Променливи на средата:
	os.environ: Речник, съдържащ променливите на средата.
	os.getenv(varname, value=None): Връща стойността на променлива на средата varname. Ако променливата не съществува, връща value (или None по подразбиране).
print(f"Път към Python изпълнимия файл: {os.environ.get('PYTHON_EXECUTABLE')}")
print(f"Потребителско име: {os.getenv('USERNAME')}") # На Windows
print(f"Потребителско име: {os.getenv('USER')}")   # На Linux/macOS

	Други системни функции:
	os.name: Връща името на операционната система ('posix', 'nt', 'java').
	os.sep: Връща разделителя на пътища за текущата операционна система ('/' за POSIX, '' за Windows).
print(f"Име на операционната система: {os.name}")
print(f"Разделител на пътища: {os.sep}")
Модулът os е изключително полезен, когато вашата Python програма трябва да взаимодейства с операционната система, например за управление на файлове и директории, изпълнение на външни команди или достъп до системна информация.
При работа с пътища е силно препоръчително да използвате функциите от os.path, тъй като те осигуряват начин за работа с пътища, който е преносим между различни операционни системи.

Казус 1: Изчисляване на геометрични фигури
Напишете програма, която пита потребителя каква геометрична фигура иска да изчисли (например "кръг" или "правоъгълник"). В зависимост от избора, програмата трябва да поиска необходимите размери (радиус за кръг, ширина и височина за правоъгълник) и да изчисли съответно площта или периметъра, като използва функции от модула math.
import math

def calculate_circle():
    try:
        radius_str = input("Въведете радиус на кръга: ")
        radius = float(radius_str)
        area = math.pi * radius ** 2
        circumference = 2 * math.pi * radius
        print(f"Площ на кръга: {area:.2f}")
        print(f"Обиколка на кръга: {circumference:.2f}")
    except ValueError:
        print("Грешка: Моля, въведете валидно число за радиус.")

def calculate_rectangle():
    try:
        width_str = input("Въведете ширина на правоъгълника: ")
        height_str = input("Въведете височина на правоъгълника: ")
        width = float(width_str)
        height = float(height_str)
        area = width * height
        perimeter = 2 * (width + height)
        print(f"Площ на правоъгълника: {area:.2f}")
        print(f"Периметър на правоъгълника: {perimeter:.2f}")
    except ValueError:
        print("Грешка: Моля, въведете валидни числа за ширина и височина.")

figure_choice = input("Изберете фигура (кръг или правоъгълник): ").lower()

if figure_choice == "кръг":
    calculate_circle()
elif figure_choice == "правоъгълник":
    calculate_rectangle()
else:
    print("Грешка: Невалиден избор на фигура.")

Казус 2: Работа с дати и часове
Напишете програма, която:
	Извежда текущата дата и час във формат "Ден.Месец.Година Час:Минути:Секунди".
	Пита потребителя за рождена дата във формат "YYYY-MM-DD".
	Изчислява и извежда възрастта на потребителя в години.
Използвайте модула datetime за тези операции.
Решение:
import datetime

# Извеждане на текуща дата и час
now = datetime.datetime.now()
formatted_now = now.strftime("%d.%m.%Y %H:%M:%S")
print(f"Текуща дата и час: {formatted_now}")

# Вход за рождена дата
birth_date_str = input("Въведете вашата рождена дата във формат YYYY-MM-DD: ")

try:
    birth_date = datetime.datetime.strptime(birth_date_str, "%Y-%m-%d").date()
    today = datetime.date.today()
    age = today.year - birth_date.year - ((today.month, today.day) < (birth_date.month, birth_date.day))
    print(f"Вашата възраст е: {age} години.")
except ValueError:
    print("Грешка: Невалиден формат на дата. Моля, използвайте YYYY-MM-DD.")

Казус 3: Работа с файлова система
Напишете програма, която:
	Извежда текущата работна директория.
	Пита потребителя за име на директория, която иска да създаде.
	Създава тази директория, ако тя не съществува.
	Извежда списък с всички файлове и поддиректории в текущата работна директория.
Използвайте модула os за тези операции.
Решение:
import os

# Извеждане на текуща работна директория
current_dir = os.getcwd()
print(f"Текуща работна директория: {current_dir}")

# Създаване на нова директория
new_dir_name = input("Въведете име на директория, която искате да създадете: ")
new_dir_path = os.path.join(current_dir, new_dir_name)

if not os.path.exists(new_dir_path):
    try:
        os.makedirs(new_dir_path)
        print(f"Директория '{new_dir_name}' беше успешно създадена.")
    except OSError as e:
        print(f"Грешка при създаване на директория: {e}")
else:
    print(f"Директория '{new_dir_name}' вече съществува.")

# Извеждане на списък с файлове и директории
print("\nСъдържание на текущата работна директория:")
for item in os.listdir(current_dir):
    print(item)

Казус 4: Инсталиране и използване на външен пакет (requests)
Забележка: За този казус се предполага, че читателят има инсталиран pip и има достъп до интернет.
	Инсталирайте пакета requests с помощта на pip (ако вече не е инсталиран).
	Напишете програма, която пита потребителя за URL адрес.
	Използвайте пакета requests, за да направите GET заявка към този URL.
	Изведете статус кода на отговора (например 200 за успешна заявка, 404 за не намерен).
Решение:
Инсталиране (изпълнете в терминал/команден прозорец):
pip install requests

import requests

url = input("Въведете URL адрес: ")

try:
    response = requests.get(url)
    print(f"Статус код на отговора: {response.status_code}")
except requests.exceptions.RequestException as e:
    print(f"Възникна грешка при заявката: {e}")

	Тези казуси демонстрират как да се импортират и използват модули от стандартната библиотека (math, datetime, os), както и как да се инсталира и използва външен пакет (requests). Те обхващат основните операции, свързани с работата с модули и пакети в Python.


Въпроси:
	Каква е разликата между модул и пакет в Python? Как се организират те?
	Обяснете различните начини за импортиране на модули и имена в Python (import, import as, from ... import ...). Какви са предимствата и недостатъците на всеки метод?
	Какво е pip и за какво се използва? Как се инсталира външен пакет с помощта на pip?
	Модулът math част ли е от стандартната библиотека на Python или трябва да се инсталира отделно? Избройте няколко полезни функции и константи, които предоставя.
	За какво се използва модулът datetime? Избройте основните класове, които съдържа, и дайте кратко описание на всеки от тях.
	Какви основни операции с файловата система може да се извършват с помощта на модула os? Дайте примери за няколко често използвани функции.
	Как може да се получи достъп до променливите на средата с помощта на модула os? Защо това може да бъде полезно?
	Каква е разликата между os.path.join() и простото съединяване на низове за създаване на пътища към файлове? Защо е препоръчително да се използва os.path.join()?
	Защо се препоръчва да се избягва използването на from име_на_модул import *, ако е възможно?
	Как може да се провери дали даден модул е инсталиран във вашата Python среда?
Задачи:
1.  Напишете програма, която използва модула math за изчисляване на косинус от 60 градуса. Изведете резултата. (Не забравяйте да преобразувате градусите в радиани).
	Напишете програма, която използва модула datetime за да: 
	Изведе текущата дата и час.
	Създаде обект date за дадена дата (например 25 декември 2024 г.).
	Изчисли разликата в дни между днешната дата и създадената дата.
	Форматира текущата дата във формат "ден/месец/година".
    3. Напишете програма, която използва модула os за да: 
	Изведе текущата работна директория.
	Създаде нова директория с име "temp_dir".
	Провери дали създадената директория съществува.
	Премахне създадената директория.
	Напишете функция, която приема път към файл като аргумент и използва модула os.path за да върне само името на файла (без пътя и разширението).
	Инсталирайте външния пакет requests с помощта на pip. След това напишете кратък код, който използва requests за да направи GET заявка към "https://www.example.com" и изведе статус кода на отговора. (Уверете се, че имате интернет връзка).
	Създайте прост пакет с име my_utilities, който съдържа два модула: string_utils.py (с функция за обръщане на низ) и math_utils.py (с функция за повдигане на число на квадрат). Импортирайте и използвайте тези функции в друг Python файл.
	Напишете програма, която използва os.environ за да изведе стойността на системната променлива PATH.
	Напишете функция, която приема две дати като низове във формат "YYYY-MM-DD" и използва datetime.datetime.strptime() за да ги преобразува в date обекти. След това върнете разликата в дни между тях.
	Напишете програма, която използва os.listdir() за да изведе всички файлове и директории в текущата директория. Филтрирайте и изведете само файловете.
	Напишете програма, която използва os.path.join() за да създаде пълен път до файл с име "data.txt" в директория "my_project", независимо от операционната система.



	Въведение в NumPy
 
NumPy е фундаментална библиотека за числени изчисления в Python. Тя предоставя поддръжка за многомерни масиви (arrays) и голям набор от високопроизводителни функции за работа с тези масиви. NumPy е в основата на много други научни библиотеки в Python, включително pandas, SciPy, scikit-learn и други.
	Защо NumPy е важен за pandas?
Библиотеката pandas е изградена върху NumPy. Това означава, че основните структури от данни в pandas - Series (едномерен етикетиран масив) и DataFrame (двумерна таблична структура с етикетирани редове и колони) - са реализирани с помощта на NumPy arrays.
Ето няколко ключови причини защо NumPy е толкова важен за pandas:
	Ефективност: NumPy arrays осигуряват ефективно съхранение и бързи операции върху големи количества числови данни. Те са имплементирани на C, което ги прави значително по-бързи от стандартните Python списъци за числени изчисления. Pandas се възползва от тази ефективност, което позволява бърза обработка на големи набори от данни.
	Еднородност на данните: NumPy arrays обикновено съдържат елементи от един и същ тип данни (например всички елементи са цели числа или числа с плаваща запетая). Тази еднородност позволява оптимизации на ниво памет и процесор, което води до по-бързи изчисления. Pandas Series също обикновено съдържат данни от един и същ тип (dtype), който се управлява от NumPy.
	Векторизирани операции (Broadcasting): NumPy поддържа векторизирани операции, което означава, че можете да прилагате операции към целия масив наведнъж, без да е необходимо да използвате явни цикли (като for цикъл). Тези векторизирани операции са много по-бързи и по-елегантни от еквивалентните операции с цикли. Pandas Series и DataFrame също поддържат векторизирани операции, които се изпълняват под капака с помощта на NumPy.
	Функционалност: NumPy предоставя богат набор от математически, логически и статистически функции, които могат да се прилагат върху масиви. Pandas използва много от тези NumPy функции за своите операции (например изчисляване на средна стойност, стандартно отклонение, сумиране и др.).
	Интеграция с други библиотеки: Тъй като NumPy е основна библиотека за научни изчисления в Python, pandas лесно се интегрира с други библиотеки, които също използват NumPy arrays (например SciPy за научни изчисления, Matplotlib и Seaborn за визуализация, scikit-learn за машинно обучение). Това позволява плавен работен процес при анализ на данни, където често се използват няколко различни библиотеки.
Пример:
Представете си, че имате pandas Series, съдържащ цени на акции:
import pandas as pd
import numpy as np

prices = pd.Series([10.5, 11.2, 10.8, 11.5, 10.9])
print(type(prices.values))
Атрибутът .values на pandas Series връща NumPy array, съдържащ данните от Series-а. Всички операции, които прилагате към този Series (например добавяне на константа, умножение, филтриране), се извършват ефективно с помощта на NumPy под капака.
В заключение, NumPy е жизненоважна основа за pandas, осигурявайки ефективност, функционалност и интеграция, които са необходими за мощния анализ на данни, който pandas предлага. Разбирането на основите на NumPy ще ви помогне да разберете по-добре как работи pandas и как да извлечете максимума от него.

	Създаване на NumPy arrays (np.array())
Основният начин за създаване на NumPy array е с помощта на функцията np.array(). Тази функция приема като аргумент обект, подобен на последователност (например Python списък, кортеж) и връща NumPy array, съдържащ елементите на тази последователност.
	Създаване на едномерни масиви (1D arrays):
Можете да създадете едномерни NumPy arrays от Python списъци или кортежи.
import numpy as np

# От списък
my_list = [1, 2, 3, 4, 5]
numpy_array_from_list = np.array(my_list)
print(numpy_array_from_list)  #[1 2 3 4 5]
print(type(numpy_array_from_list)) # <class 'numpy.ndarray'>
# От кортеж
my_tuple = (10, 20, 30)
numpy_array_from_tuple = np.array(my_tuple)
print(numpy_array_from_tuple) #[10 20 30]
print(type(numpy_array_from_tuple)) # <class 'numpy.ndarray'>

	Създаване на многомерни масиви (multi-dimensional arrays):
За да създадете многомерен масив (например двумерен масив, който може да представлява матрица), можете да подадете списък от списъци (или кортежи) на функцията np.array().
# Двумерен масив (2D array) от списък от списъци
list_of_lists = [[1, 2, 3], [4, 5, 6]]
numpy_2d_array = np.array(list_of_lists)
print(numpy_2d_array)
#[[1 2 3]
#[4 5 6]]
# Тримерен масив (3D array) от списък от списъци от списъци
list_of_lists_of_lists = [[[1, 2], [3, 4]], [[5, 6], [7, 8]]]
numpy_3d_array = np.array(list_of_lists_of_lists)
print(numpy_3d_array)
#[[[1 2]
#[3 4]]

#[[5 6]
#[7 8]]]

	Определяне на типа на данните (dtype):
По подразбиране, NumPy се опитва да определи подходящия тип данни за елементите на масива въз основа на подадената последователност. Въпреки това, можете изрично да зададете типа на данните с помощта на аргумента dtype. Това може да бъде полезно за контролиране на размера на паметта или за осигуряване на съвместимост с други библиотеки.
# Създаване на масив с тип данни integer (int32)
int_array = np.array([1, 2, 3], dtype=np.int32)
print(int_array)
print(int_array.dtype)
#[1 2 3]
#int32]
# Създаване на масив с тип данни float (float64)
float_array = np.array([1, 2, 3], dtype=np.float64)
print(float_array)
print(float_array.dtype)

#[1. 2. 3.]
#float64
# Създаване на масив с тип данни boolean
bool_array = np.array([0, 1, 0, 1], dtype=np.bool_)
print(bool_array)
print(bool_array.dtype)
#[False  True False  True]
#bool
NumPy поддържа голям набор от числови типове данни, включително различни размери на цели числа (int8, int16, int32, int64), числа с плаваща запетая (float16, float32, float64), комплексни числа (complex64, complex128) и други.
	Създаване на масиви с еднакъв тип данни:
Ако елементите на подадената последователност са от различни типове, NumPy ще се опита да ги преобразува до най-общия тип, който може да ги побере. Например, ако имате списък, съдържащ цели числа и числа с плаваща запетая, резултатният NumPy array ще бъде от тип float.
mixed_list = [1, 2.5, 3, 4.0]
mixed_array = np.array(mixed_list)
print(mixed_array)
print(mixed_array.dtype)
#[1.  2.5 3.  4. ]
#float64
Функцията np.array() е основният инструмент за създаване на NumPy arrays от съществуващи Python обекти. В следващите подглави ще разгледаме други начини за създаване на NumPy arrays, както и техните основни атрибути и операции.

	Основни атрибути (.shape, .dtype, .ndim) 
	.shape - Форма на масива:
Атрибутът .shape връща кортеж, който представлява размерите на NumPy array по всяка от неговите оси. Дължината на кортежа е равна на броя на измеренията (ndim), а всеки елемент на кортежа указва броя на елементите по съответната ос.
	Едномерни масиви (1D arrays): 
.shape връща кортеж с един елемент, който е дължината на масива.
import numpy as np

array_1d = np.array([1, 2, 3, 4, 5])
print(array_1d.shape)  # Извежда: (5,)

Кортежът (5,) показва, че array_1d има едно измерение с 5 елемента. Забележете запетаята след 5, която указва, че това е кортеж с един елемент.
	Двумерни масиви (2D arrays): 
.shape връща кортеж с два елемента: (брой редове, брой колони).
array_2d = np.array([[1, 2, 3], [4, 5, 6]])
print(array_2d.shape)  # Извежда: (2, 3)
Кортежът (2, 3) показва, че array_2d има 2 реда и 3 колони.
	Тримерни масиви (3D arrays): 
.shape връща кортеж с три елемента: (брой на "дълбочина", брой редове, брой колони). Представете си 3D масива като куб от числа.
array_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(array_3d.shape)  # Извежда: (2, 2, 2)
Разбирането на формата на масива е ключово при извършване на операции върху него, особено при broadcasting (което ще разгледаме по-късно).

	.dtype - Тип на данните:
Атрибутът .dtype връща обект, който описва типа на данните на елементите в NumPy array. Както споменахме по-рано, NumPy arrays обикновено съдържат елементи от един и същ тип.
array_int = np.array([1, 2, 3])
print(array_int.dtype)   # Извежда: int64 (или int32 в зависимост от системата)

array_float = np.array([1.0, 2.5, 3.7])
print(array_float.dtype) # Извежда: float64

array_bool = np.array([True, False, True])
print(array_bool.dtype)  # Извежда: bool

array_str = np.array(['a', 'b', 'c'])
print(array_str.dtype)   # Извежда: <U1 (Unicode string с дължина до 1 символ)
NumPy поддържа голямо разнообразие от типове данни, които могат да бъдат по-специфични от стандартните Python типове (например различни размери на цели числа и числа с плаваща запетая). Явното задаване на dtype при създаване на масив може да бъде важно за ефективно използване на паметта и за осигуряване на правилни резултати при определени операции.
	.ndim - Брой на измеренията:
Атрибутът .ndim връща цяло число, което указва броя на измеренията (осите) на NumPy array.
	Едномерни масиви: 
.ndim е 1.
array_1d = np.array([1, 2, 3, 4, 5])
print(array_1d.ndim)  # Извежда: 1

	Двумерни масиви: 
.ndim е 2.
array_2d = np.array([[1, 2, 3], [4, 5, 6]])
print(array_2d.ndim)  # Извежда: 2

	Тримерни масиви: 
.ndim е 3.
   array_3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(array_3d.ndim)  # Извежда: 3
Броят на измеренията съответства на дължината на кортежа, върнат от .shape.

	Разбирането и използването на тези основни атрибути е важна стъпка при работа с NumPy arrays, тъй като те ви позволяват да инспектирате структурата и типа на данните във вашите масиви.

	Основни операции (елементни операции, broadcasting)

	Елементни операции (Element-wise operations):
Една от ключовите характеристики на NumPy е способността да извършва операции върху всички елементи на масива едновременно, без да е необходимо да се използват явни цикли. Тези операции се прилагат поелементно.
	Аритметични операции: 
Можете да използвате стандартните аритметични оператори (+, -, *, /, // - целочислено деление, ** - степен) за извършване на поелементни операции между масиви със съвместими размери или между масив и скаларна стойност.
import numpy as np

a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# Поелементно събиране
print(a + b)       # Извежда: [5 7 9]

# Поелементно изваждане
print(b - a)       # Извежда: [3 3 3]

# Поелементно умножение
print(a * b)       # Извежда: [ 4 10 18]

# Поелементно деление
print(b / a)       # Извежда: [4.         2.5        2.        ]

# Умножение на масив със скалар
print(a * 2)       # Извежда: [2 4 6]

# Степенуване на масив със скалар
print(a ** 2)      # Извежда: [1 4 9]

	Сравнителни операции: 
Сравнителните оператори (==, !=, <, >, <=, >=) също се прилагат поелементно и връщат булев масив със същия размер.
a = np.array([1, 2, 3, 4, 5])
b = np.array([3, 2, 1, 4, 6])

print(a == b)      # Извежда: [False  True False  True False]
print(a > b)       # Извежда: [False False  True False False]

	Логически операции: 
	Логическите оператори (& - and, | - or, ^ - xor, ~ - not) могат да се използват за поелементни логически операции върху булеви масиви.
bool_a = np.array([True, False, True, False])
bool_b = np.array([True, True, False, False])

print(bool_a & bool_b)  # Извежда: [ True False False False]
print(bool_a | bool_b)  # Извежда: [ True  True  True False]
print(~bool_a)         # Извежда: [False  True False  True]

	Broadcasting:
Broadcasting е мощен механизъм в NumPy, който позволява извършването на аритметични операции върху масиви с различни форми, при определени условия. NumPy автоматично "разширява" по-малкия масив, така че неговата форма да съвпадне с формата на по-големия масив.
Правилата за broadcasting са:
	Съвместимост по размерност: Две размерности са съвместими, когато са равни, или една от тях е 1.
	Разширяване по размерност 1: Ако размерностите на два масива не съвпадат, но една от тях е 1, масивът с размерност 1 се "разтяга" (broadcasted) по тази размерност, за да съвпадне с размера на другия масив.
Нека разгледаме няколко примера:
	Масив и скалар: 
Скаларът се broadcast-ва към всички елементи на масива.
a = np.array([1, 2, 3])
scalar = 10
print(a + scalar)    # Извежда: [11 12 13] (скаларът 10 се добавя към всеки елемент на a)
Изход:
 [[11 22 33]
 [14 25 36]]

	Масив (n x m) и масив (n x 1): 

Малкият масив се broadcast-ва по колоните.
a = np.array([[1, 2, 3], [4, 5, 6]])  # shape (2, 3)
c = np.array([[10], [20]])            # shape (2, 1)
print(a + c)

Изход:
[[11 12 13]
 [24 25 26]]
Масивът c се "разтяга" до [[10, 10, 10], [20, 20, 20]] и след това се извършва поелементно събиране.
Broadcasting прави кода по-кратък и по-ефективен, като избягва необходимостта от явни цикли при операции с масиви с различни, но съвместими форми.
Разбирането на елементните операции и broadcasting е от съществено значение за ефективната работа с NumPy и за използването на неговата мощ за числени изчисления.

 Казус 1: Анализ на височини
Представете си, че имате списък с височини на група хора в сантиметри.
	Създайте NumPy array от този списък: [170, 175, 168, 180, 172, 165].
	Изведете формата (shape), типа на данните (dtype) и броя на измеренията (ndim) на масива.
	Преобразувайте височините в метри, като разделите всеки елемент на 100. Изведете резултата.
Решение:
import numpy as np

heights_cm = [170, 175, 168, 180, 172, 165]
heights_array = np.array(heights_cm)

print("Форма на масива:", heights_array.shape)
print("Тип на данните:", heights_array.dtype)
print("Брой на измеренията:", heights_array.ndim)

heights_m = heights_array / 100
print("Височини в метри:", heights_m)

Казус 2: Работа с резултати от тест
Имате двумерен списък, представляващ резултатите на ученици от два различни теста: [[85, 90, 78], [92, 88, 95]]. Всеки вътрешен списък съответства на резултатите на един ученик.
	Създайте NumPy array от този списък.
	Изведете формата на масива. Какво представляват измеренията?
	Увеличете резултата на всеки ученик от втория тест с 5 точки. Използвайте елементна операция и broadcasting (ако е необходимо). Изведете обновените резултати.
Решение:
import numpy as np

test_results = [[85, 90, 78], [92, 88, 95]]
results_array = np.array(test_results)

print("Форма на масива:", results_array.shape)
print("Измеренията представляват (брой ученици, брой тестове).")

increase = np.array([0, 5])  # Масив за увеличение, ще бъде broadcast-нат по редовете
updated_results = results_array + increase[:, np.newaxis] # Reshape increase за broadcasting
print("Обновени резултати:", updated_results)

Казус 3: Сравнение на продажби
Имате два NumPy array-я, съдържащи дневните продажби на два продукта за една седмица: sales_product_a = np.array([20, 25, 30, 22, 28, 35, 40]) sales_product_b = np.array([15, 28, 25, 30, 32, 28, 38])
	Сравнете поелементно продажбите на двата продукта и създайте булев масив, който показва в кои дни продажбите на продукт А са били по-високи от тези на продукт Б.
	Използвайте булевия масив, за да изведете дните (индексите), в които продажбите на продукт А са били по-високи.
Решение:
import numpy as np

sales_product_a = np.array([20, 25, 30, 22, 28, 35, 40])
sales_product_b = np.array([15, 28, 25, 30, 32, 28, 38])

comparison_array = sales_product_a > sales_product_b
print("Дни, в които продажбите на продукт А са по-високи:", comparison_array)

higher_sales_indices = np.where(comparison_array)
print("Индекси на дните с по-високи продажби на продукт А:", higher_sales_indices[0])

Казус 4 (): Нормализиране на данни**
Представете си, че имате двумерен NumPy array, съдържащ резултати от различни характеристики на няколко обекта. Всяка колона представлява различна характеристика, а всеки ред - един обект. За да сравните характеристиките, често е необходимо да ги нормализирате, така че да имат средна стойност 0 и стандартно отклонение 1.
Даден е следният масив от данни:
data = np.array([[1, 5, 2],
                 [3, 2, 8],
                 [4, 7, 1],
                 [2, 4, 5]])

Напишете код, който:
	Изчислява средната стойност на всяка колона.
	Изчислява стандартното отклонение на всяка колона.
	Нормализира данните по колони, като изважда средната стойност на колоната от всеки елемент и след това разделя резултата на стандартното отклонение на колоната.
	Проверете дали средната стойност и стандартното отклонение на всяка нормализирана колона са приблизително 0 и 1 съответно.
import numpy as np

data = np.array([[1, 5, 2],
                 [3, 2, 8],
                 [4, 7, 1],
                 [2, 4, 5]])

# 1. Изчисляване на средна стойност по колони
mean_cols = np.mean(data, axis=0)
print("Средни стойности на колоните:", mean_cols)

# 2. Изчисляване на стандартно отклонение по колони
std_cols = np.std(data, axis=0)
print("Стандартни отклонения на колоните:", std_cols)

# 3. Нормализиране на данните
normalized_data = (data - mean_cols) / std_cols
print("Нормализирани данни:\n", normalized_data)

# 4. Проверка на средна стойност и стандартно отклонение на нормализираните колони
mean_normalized_cols = np.mean(normalized_data, axis=0)
std_normalized_cols = np.std(normalized_data, axis=0)

print("Средни стойности на нормализираните колони:", mean_normalized_cols)
print("Стандартни отклонения на нормализираните колони:", std_normalized_cols)
Казус 5 (): Филтриране на данни по няколко условия**
Представете си, че имате NumPy array, съдържащ информация за продажби на различни продукти за няколко месеца. Масивът има следния формат: [продукт_ид, месец, брой_продадени, цена_на_единица].
Даден е следният масив:
sales_data = np.array([[1, 1, 100, 5.5],
                       [2, 1, 50, 12.0],
                       [1, 2, 120, 5.5],
                       [3, 1, 30, 25.0],
                       [2, 2, 60, 12.0],
                       [1, 3, 90, 5.5],
                       [3, 2, 40, 25.0],
                       [2, 3, 70, 12.0]])

Напишете код, който:
	Филтрира данните, за да извлече само продажбите на продукт с продукт_ид 1.
	Филтрира допълнително резултата от стъпка 1, за да извлече само продажбите, където броят на продадените единици е по-голям от 95.
	Изведете общия приход (брой продадени * цена на единица) за тези филтрирани продажби.
Решение:
import numpy as np

sales_data = np.array([[1, 1, 100, 5.5],
                       [2, 1, 50, 12.0],
                       [1, 2, 120, 5.5],
                       [3, 1, 30, 25.0],
                       [2, 2, 60, 12.0],
                       [1, 3, 90, 5.5],
                       [3, 2, 40, 25.0],
                       [2, 3, 70, 12.0]])

# 1. Филтриране по продукт_ид == 1
product_1_sales = sales_data[sales_data[:, 0] == 1]
print("Продажби на продукт 1:\n", product_1_sales)

# 2. Филтриране по брой_продадени > 95
high_quantity_sales = product_1_sales[product_1_sales[:, 2] > 95]
print("Продажби на продукт 1 с количество > 95:\n", high_quantity_sales)

# 3. Изчисляване на общия приход
total_revenue = np.sum(high_quantity_sales[:, 2] * high_quantity_sales[:, 3])
print("Общ приход от филтрираните продажби:", total_revenue)

Тези по-сложни казуси изискват прилагането на няколко NumPy операции и концепции едновременно, като индексиране с булеви масиви, изчисляване на статистически величини по оси и комбиниране на филтриращи условия. Те са подходящи за по-задълбочено разбиране на възможностите на NumPy.

Въпроси:
	Защо библиотеката NumPy е толкова важна за pandas? Обяснете връзката между двете библиотеки.
	Как се създава NumPy array? Дайте пример за създаване на едномерни и двумерни масиви от Python списъци.
	Какво представляват атрибутите .shape, .dtype и .ndim на NumPy array? Каква информация предоставя всеки от тях? Дайте примери.
	Какво означава "елементна операция" в контекста на NumPy arrays? Дайте примери за поелементни аритметични и сравнителни операции.
	Обяснете концепцията за "broadcasting" в NumPy. Какви са правилата, които определят дали два масива могат да бъдат broadcast-нати заедно? Дайте примери.
	Обяснете защо следният код работи и какъв е резултатът:
import numpy as np
a = np.array([[1, 2, 3]])  # shape (1, 3)
b = np.array([10, 20, 30])   # shape (3,) - NumPy го третира като (1, 3) за broadcasting
result = a + b
print(result)
	Обяснете защо следният код работи и какъв е резултатът:
import numpy as np
a = np.array([[1], [2], [3]])  # shape (3, 1)
b = np.array([10, 20, 30])     # shape (3,) - NumPy го третира като (1, 3) за broadcasting
result = a + b
print(result)

Задачи:
	Създайте NumPy array от списъка [10, 20, 30, 40, 50]. Изведете неговата форма (shape), тип на данните (dtype) и брой на измеренията (ndim).
	Създайте двумерен NumPy array от списъка от списъци [[1, 2, 3], [4, 5, 6], [7, 8, 9]]. Изведете неговата форма.
	Създайте два NumPy array-я: a = np.array([1, 2, 3]) и b = np.array([4, 5, 6]). Извършете следните поелементни операции и изведете резултатите:
	Събиране (a + b)
	Умножение (a * b)
	Сравнение (a > b)
	Създайте NumPy array c = np.array([[10, 20, 30], [40, 50, 60]]). Умножете всеки елемент на масива по скаларната стойност 5 и изведете резултата.
	Създайте два NumPy array-я с различни форми, които могат да бъдат broadcast-нати заедно. Извършете аритметична операция между тях и изведете резултата и формата на резултатния масив.
	Напишете код, който създава NumPy array с булеви стойности въз основа на сравнение на друг числов масив с дадена стойност (например, проверете кои елементи на масива [5, 10, 15, 20] са по-големи от 12).
	Създайте двумерен NumPy array и изведете неговата форма. След това създайте едномерни масиви, които могат да бъдат broadcast-нати към него при поелементно събиране (по редове и по колони). Извършете тези операции и изведете резултатите.
	Опитайте се да извършите поелементна операция между два NumPy array-я с форми, които не са съвместими за broadcasting (и не са с еднаква форма). Какъв е резултатът? Защо се получава така?









	Среди за разработка (IDE) - PyCharm
  
	Какво е IDE?
IDE е съкращение от Integrated Development Environment (Интегрирана среда за разработка). Това е софтуерно приложение, което предоставя цялостни инструменти за разработчиците на софтуер на едно място. Вместо да използват множество отделни програми за писане на код, компилиране, дебъгване и други задачи, IDE обединява тези функционалности в единен и удобен интерфейс.
Представете си, че строите къща. Вместо да търсите отделно инструменти като чук, трион, рулетка и други, IDE е като многофункционален работен център, който съдържа всички необходими инструменти, подредени и лесно достъпни. Това значително улеснява и ускорява процеса на разработка.
Основните компоненти, които обикновено се съдържат в една IDE, включват:
	Редактор на код: Текстов редактор, който е специално проектиран за писане и редактиране на програмен код. Той често включва функции като подсветка на синтаксиса (оцветяване на ключови думи, променливи и други елементи на кода), автоматично довършване на код (предлагане на възможни продължения на пишещия се код), проверка за синтактични грешки в реално време и други инструменти за подобряване на продуктивността.
	Компилатор/Интерпретатор: Инструмент за преобразуване на написания код в изпълним формат (за компилирани езици) или за директно изпълнение на кода (за интерпретирани езици като Python). В някои IDE, тази функционалност е вградена или лесно интегрирана.
	Дебъгер: Инструмент, който позволява на разработчиците да стъпка по стъпка изпълняват програмата си, да следят стойностите на променливите, да поставят точки на прекъсване (breakpoints) и да анализират поведението на кода по време на изпълнение, за да открият и отстранят грешки (бъгове).
	Управление на проекти: Функционалност за организиране на файловете и директориите, свързани с даден софтуерен проект. Това може да включва създаване, отваряне, запазване и управление на проекти, както и интеграция със системи за контрол на версиите.
Освен тези основни компоненти, съвременните IDE често предлагат и множество допълнителни инструменти и интеграции, като:
	Интеграция със системи за контрол на версиите (VCS): Поддръжка за Git, SVN и други системи за управление на промените в кода.
	Инструменти за тестване: Интеграция с фреймворци за автоматизирано тестване на кода.
	Профилиране: Инструменти за анализ на производителността на програмата.
	Поддръжка за бази данни: Възможност за свързване и работа с бази данни.
	Графичен потребителски интерфейс (GUI) дизайнери: Инструменти за визуално създаване на потребителски интерфейси.
	Поддръжка за различни програмни езици и технологии: Една IDE може да поддържа множество езици или да е специализирана за конкретен език.
Използването на IDE значително повишава ефективността на разработчиците, като предоставя всички необходими инструменти на едно място и автоматизира много от рутинните задачи. Това позволява на програмистите да се фокусират повече върху логиката и дизайна на своя код.
	Видове IDE
	PyCharm: Мощна и широко използвана IDE, специално разработена за Python. Предлага отлични инструменти за редактиране, дебъгване, тестване, управление на проекти и интеграция с VCS (като Git). Има платена (Professional) и безплатна (Community) версия.
	Visual Studio Code (VS Code): Безплатен, лек, но изключително гъвкав редактор на код, който може да бъде разширен с множество плъгини за поддръжка на различни езици за програмиране (включително Python), дебъгване, Git и други инструменти. Много популярен сред уеб разработчиците и data scientists.
	IntelliJ IDEA: Мощна платена IDE от същата компания като PyCharm (JetBrains), но е фокусирана основно върху Java. Въпреки това, предлага отлична поддръжка и за Python чрез плъгини.
	Eclipse: Безплатна и open-source IDE, която първоначално е разработена за Java, но има богата екосистема от плъгини, които я правят подходяща и за Python разработка (чрез плъгина PyDev).
	Sublime Text: Платен, но много бърз и елегантен текстов редактор с богата функционалност чрез плъгини. Въпреки че технически е текстов редактор, с правилните плъгини може да функционира като лека IDE за Python.
	Spyder: Безплатна и open-source IDE, която е специално насочена към научни изчисления и анализ на данни с Python. Интегрира добре библиотеки като NumPy, SciPy и Matplotlib.
	Jupyter Notebook/JupyterLab: Уеб-базирани среди за разработка, които позволяват създаването и споделянето на документи, съдържащи жив код, уравнения, визуализации и обяснителен текст. Много популярни в областта на data science, машинното обучение и образованието.

	Тези примери илюстрират разнообразието от IDE, налични за разработчиците, всяка със своите силни страни и специфични характеристики. Изборът на IDE често зависи от предпочитанията на разработчика, езика/езиците, с които работи, и нуждите на проекта.

	Представяне на PyCharm
PyCharm е мощна и популярна интегрирана среда за разработка (IDE), създадена от компанията JetBrains, която е специализирана в разработването на инструменти за програмисти. PyCharm е специално проектиран за разработка на проекти с езика за програмиране Python и предлага богат набор от инструменти и функции, които значително улесняват и ускоряват процеса на писане, тестване и поддръжка на Python код.
PyCharm се предлага в две основни версии:
	PyCharm Professional: Платена версия, която предлага пълния набор от функции, включително поддръжка за уеб разработка (Django, Flask), работа с бази данни, научни инструменти (NumPy, SciPy, Matplotlib), JavaScript, TypeScript и други.
	PyCharm Community: Безплатна и open-source версия, която е фокусирана върху основните Python разработки и предлага основните инструменти за редактиране, дебъгване и управление на проекти.
В следващите точки ще разгледаме основните характеристики на PyCharm:
1. Интелигентен редактор на код:
Редакторът на код в PyCharm е един от най-силните му аспекти. Той предлага множество функции, които помагат на разработчиците да пишат код по-бързо и с по-малко грешки:
	Подсветка на синтаксиса (Syntax Highlighting): Различава различните елементи на Python кода (ключови думи, променливи, функции и др.) с различни цветове и стилове, което прави кода по-лесен за четене и разбиране.
	Автоматично довършване на код (Code Completion/IntelliSense): Докато пишете код, PyCharm предлага възможни продължения на думи, имена на променливи, функции, методи и класове, като взема предвид контекста на кода. Това спестява време и намалява вероятността от правописни грешки.
	Проверка за грешки в реално време (On-the-fly Error Checking): PyCharm анализира кода ви докато го пишете и подчертава потенциални синтактични грешки, стилови нарушения (според PEP 8) и други проблеми, като ви дава незабавна обратна връзка.
	Бързи поправки (Quick Fixes): Когато PyCharm открие проблем в кода, често предлага бързи начини за автоматичното му коригиране.
	Навигация в кода: Лесни начини за навигиране между дефиниции на променливи, функции и класове (Go to Definition), търсене на употреби (Find Usages) и бързо превключване между отворени файлове.
	Преформатиране на код (Code Formatting): Автоматично преформатиране на кода според стандартите (например PEP 8), което гарантира консистентност и четимост.
	Шаблони на код (Code Snippets/Live Templates): Предварително дефинирани фрагменти от код за често използвани конструкции (например цикли, условни оператори, дефиниции на функции), които могат да бъдат бързо вмъкнати и персонализирани.
2. Мощен дебъгер:
Дебъгерът в PyCharm е изключително полезен инструмент за откриване и отстраняване на грешки в кода:
	Точки на прекъсване (Breakpoints): Позволява ви да спрете изпълнението на програмата на определени редове код, за да инспектирате състоянието на променливите и потока на изпълнение.
	Стъпково изпълнение (Step-by-step Execution): Възможност за изпълнение на кода ред по ред (Step Over, Step Into, Step Out), което ви позволява да проследите как се променят стойностите на променливите и как се изпълняват различните части на програмата.
	Инспектиране на променливи (Variable Inspection): Показва стойностите на променливите в текущия контекст по време на дебъгване. Можете да наблюдавате сложни структури от данни като списъци и речници.
	Условни точки на прекъсване (Conditional Breakpoints): Възможност за задаване на точки на прекъсване, които се активират само когато е изпълнено определено условие.
	Оценка на изрази (Evaluate Expressions): Позволява ви да изпълнявате произволни Python изрази по време на дебъгване и да виждате резултата.
3. Интелигентно управление на проекти:
PyCharm помага за организирането и управлението на вашите проекти:
	Структуриране на проекти: Предоставя ясен начин за организиране на файлове, директории и виртуални среди в рамките на един проект.
	Поддръжка на виртуални среди (Virtual Environments): Интегрирана поддръжка за създаване и активиране на виртуални среди (като venv и conda), което е ключово за изолиране на зависимостите на различните проекти.
	Управление на зависимости: Лесно инсталиране, обновяване и премахване на Python пакети чрез вградения мениджър на пакети (например pip).

4. Интеграция с Git и други системи за контрол на версиите:
PyCharm предлага отлична интеграция със системите за контрол на версиите, най-вече Git:
	Вградени Git команди: Възможност за извършване на често използвани Git операции (commit, push, pull, branch, merge, diff и др.) директно от IDE, без да е необходимо да използвате командния ред.
	Визуализация на промените: Лесно проследяване на промените във файловете, преглед на разликите между версиите и разрешаване на конфликти при сливане.
	История на репозитория: Преглед на историята на коммитите, клоновете и други аспекти на Git репозиторията.
5. Поддръжка за тестване:
PyCharm улеснява писането и изпълнението на тестове:
	Интеграция с фреймворци за тестване: Поддръжка за популярни Python фреймворци за тестване като unittest, pytest и nose.
	Изпълнение на тестове от IDE: Възможност за лесно стартиране на отделни тестове, тестови класове или цели тестови набори директно от IDE.
	Визуализация на резултатите от тестовете: Ясно показване на резултатите от тестовете (успешни, неуспешни, грешки) с възможност за навигиране до кода, където е възникнал проблемът.
	Създаване на тестови конфигурации: Възможност за създаване на различни конфигурации за изпълнение на тестове с различни параметри.
	В заключение, PyCharm е изключително мощен и продуктивен инструмент за Python разработка, който предлага широк набор от функции, насочени към улесняване на всеки аспект от процеса на разработка. Независимо дали сте начинаещ или опитен програмист, PyCharm може значително да подобри вашата ефективност и качеството на вашия код.

	Инсталиране и основни настройки на PyCharm
Инсталирането на PyCharm е сравнително лесен процес, който варира леко в зависимост от вашата операционна система (Windows, macOS или Linux). След като инсталацията приключи, има няколко основни настройки, които може да конфигурирате, за да персонализирате IDE според вашите предпочитания.
1. Инсталиране на PyCharm:
	Windows:
	Отворете уебсайта на JetBrains: https://www.jetbrains.com/pycharm/download/
	Изберете версията, която искате да изтеглите: 
	Professional: Платена версия с пълен набор от функции. Можете да изпробвате безплатно за определен период.
	Community: Безплатна версия, подходяща за основни Python проекти.
	Кликнете върху бутона за изтегляне за Windows (.exe файл).
	След като файлът се изтегли, стартирайте го, като кликнете два пъти върху него.
	Следвайте инструкциите на инсталационния съветник. Препоръчително е да оставите отметнати опциите за създаване на асоциации с .py файлове и добавяне на PyCharm към PATH (за да може да се стартира от командния ред). Можете също да създадете шорткът на работния плот.
	След като инсталацията завърши, рестартирайте компютъра си, ако бъдете подканени, или просто стартирайте PyCharm.
	macOS:
	Отворете уебсайта на JetBrains: https://www.jetbrains.com/pycharm/download/
	Изберете версията, която искате да изтеглите (.dmg файл).
	След като файлът се изтегли, отворете го.
	Плъзнете иконата на PyCharm в папката "Applications".
	Стартирайте PyCharm от папката "Applications" или чрез Spotlight. При първото стартиране може да бъдете попитани дали сте сигурни, че искате да отворите приложението, тъй като е изтеглено от интернет. Потвърдете.
	Linux:
	Отворете уебсайта на JetBrains: https://www.jetbrains.com/pycharm/download/
	Изберете версията, която искате да изтеглите (.tar.gz файл).
	Отворете терминал и навигирайте до директорията, където сте изтеглили файла.
	Разархивирайте файла с командата: tar -xzf pycharm-community-<версия>.tar.gz (за Community версията) или tar -xzf pycharm-professional-<версия>.tar.gz (за Professional версията), като замените <версия> с точната версия на файла.
	Навигирайте до създадената директория pycharm-community-<версия>/bin/ или pycharm-professional-<версия>/bin/.
	Стартирайте PyCharm с командата: ./pycharm.sh.
	Може да бъдете попитани дали искате да създадете шорткът на работния плот.
2. Основни настройки на PyCharm (при първо стартиране):
При първото стартиране на PyCharm ще преминете през няколко стъпки за основни настройки:
	Импортиране на настройки (Import Settings): Ако сте използвали предишна версия на PyCharm или други IDE на JetBrains, можете да импортирате вашите настройки. Ако сте нов потребител, изберете "Do not import settings".
	Лиценз (License Activation) (само за Professional версията): Ако използвате Professional версията, ще трябва да активирате лиценза си, като въведете потребителското си име и парола от JetBrains акаунта си или като предоставите лицензен ключ. Community версията е безплатна и не изисква лиценз.
	Тема (UI Theme): Можете да изберете между светла ("IntelliJ Light") и тъмна ("Darcula") тема. Тъмната тема е предпочитана от много програмисти, тъй като може да намали напрежението върху очите при продължителна работа. Можете да промените темата по-късно от настройките.
	Редактор (Editor Settings):
	Размер на шрифта и схема на цветовете (Font and Color Scheme): Можете да персонализирате размера и вида на шрифта, както и цветовите схеми за различните елементи на кода. Отидете на File -> Settings (или PyCharm -> Preferences на macOS) -> Editor -> Font и Editor -> Color Scheme.
	Подсветка на синтаксиса (Syntax Highlighting): Вече е настроена по подразбиране, но можете да я персонализирате от Editor -> Color Scheme -> Python.
	Автоматично довършване на код (Code Completion): Обикновено е активирано по подразбиране. Можете да конфигурирате неговото поведение от Editor -> General -> Code Completion.
	Показване на номера на редовете (Show Line Numbers): Препоръчително е да активирате показването на номерата на редовете за по-лесно ориентиране в кода и при съобщения за грешки. Отидете на Editor -> General и отметнете "Show line numbers".
	Индикатори за код (Code Style): Можете да настроите правилата за форматиране на кода (например брой интервали за отстъп, дължина на реда) от Editor -> Code Style -> Python.
	
	Проекти (Projects):
	При първото стартиране ще бъдете подканени да създадете нов проект или да отворите съществуващ. За нов проект изберете "New Project", задайте местоположението на проекта, изберете интерпретатор на Python (ако вече имате инсталиран) или конфигурирайте нов. Препоръчително е да създавате виртуална среда за всеки нов проект, за да изолирате зависимостите. PyCharm обикновено предлага опция за автоматично създаване на такава.
	Плъгини (Plugins): PyCharm поддържа голям брой плъгини, които могат да разширят функционалността на IDE. Можете да разгледате и инсталирате плъгини от File -> Settings (или PyCharm -> Preferences на macOS) -> Plugins. Някои полезни плъгини за Python включват такива за линтинг (проверка за стилови грешки), поддръжка на допълнителни езици или фреймворци и др.
След като преминете през тези основни настройки, PyCharm ще бъде готов за използване. Можете да започнете да създавате или отваряте Python проекти и да се възползвате от всички функции, които IDE предлага. Не забравяйте, че можете да променяте тези и много други настройки по всяко време от менюто File -> Settings (или PyCharm -> Preferences на macOS).














	
